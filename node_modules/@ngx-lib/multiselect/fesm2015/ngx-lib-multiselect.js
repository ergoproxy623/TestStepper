import { Injectable, ɵɵdefineInjectable, EventEmitter, Component, ChangeDetectionStrategy, Output, forwardRef, ElementRef, HostBinding, Input, ContentChild, TemplateRef, ViewChild, HostListener, Pipe, Directive, Renderer2, NgModule } from '@angular/core';
import { FormControl, NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/multiselect.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const matchSelectors = [
    'matches',
    'webkitMatchesSelector',
    'mozMatchesSelector',
    'msMatchesSelector',
    'oMatchesSelector'
];
class NgxMultiselectService {
    constructor() { }
    /**
     * @param {?} node
     * @param {?} selector
     * @return {?}
     */
    pseudoClassExist(node, selector) {
        /** @type {?} */
        const nativeMatches = node.matches || node.msMatchesSelector;
        try {
            return nativeMatches.call(node, selector);
        }
        catch (error) {
            return false;
        }
    }
    /**
     * @param {?} el
     * @param {?} selector
     * @return {?}
     */
    closest(el, selector) {
        /** @type {?} */
        let matchesFn;
        // find vendor prefix
        matchSelectors.some((/**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (typeof document.body[fn] === 'function') {
                matchesFn = fn;
                return true;
            }
            return false;
        }));
        /** @type {?} */
        let parent;
        // traverse parents
        while (el) {
            parent = el.parentElement;
            if (parent && parent[matchesFn](selector)) {
                return parent;
            }
            el = parent;
        }
        return false;
    }
    // TODO: make this logic to work to find all descendant groups
    /**
     * @param {?} collection
     * @param {?} groupProperty
     * @param {?} groupName
     * @return {?}
     */
    collectAllDescendants(collection, groupProperty, groupName) {
        /** @type {?} */
        const allDescendants = collection.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => item[groupProperty] == groupName));
        allDescendants.concat(collection.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => item.parent == groupName)));
        return allDescendants;
    }
    /**
     * @private
     * @param {?} collection
     * @param {?} groupProperty
     * @param {?} groupName
     * @return {?}
     */
    allDescendantsAreTicked(collection, groupProperty, groupName) {
        /** @type {?} */
        const allDescendants = this.collectAllDescendants(collection, groupProperty, groupName);
        /** @type {?} */
        const allAreTicked = allDescendants.every((/**
         * @param {?} d
         * @return {?}
         */
        d => d.ticked));
        return allAreTicked;
    }
    /**
     * @private
     * @param {?} collection
     * @param {?} groupProperty
     * @param {?} groupName
     * @return {?}
     */
    allDescendantsAreDisabled(collection, groupProperty, groupName) {
        /** @type {?} */
        const allDescendants = this.collectAllDescendants(collection, groupProperty, groupName);
        /** @type {?} */
        const allAreDisabled = allDescendants.every((/**
         * @param {?} d
         * @return {?}
         */
        d => d.disabled));
        return allAreDisabled;
    }
    /**
     * @param {?} options
     * @param {?} groupByProperty
     * @return {?}
     */
    optionsGrouping(options, groupByProperty) {
        /** @type {?} */
        const getAllUniqueGroupByPropertyValue = this.findUnique(options.map((/**
         * @param {?} item
         * @return {?}
         */
        item => item[groupByProperty])));
        /** @type {?} */
        const result = getAllUniqueGroupByPropertyValue.map((/**
         * @param {?} group
         * @return {?}
         */
        group => {
            /** @type {?} */
            const groupedValues = options.filter((/**
             * @param {?} o
             * @return {?}
             */
            o => o[groupByProperty] === group));
            return {
                name: group,
                values: groupedValues,
                ticked: groupedValues.every((/**
                 * @param {?} o
                 * @return {?}
                 */
                o => o.ticked)),
                disabled: groupedValues.every((/**
                 * @param {?} o
                 * @return {?}
                 */
                o => o.disabled))
            };
        }));
        return result;
    }
    /**
     * @param {?} expression
     * @return {?}
     */
    findUnique(expression) {
        return [...Array.from(new Set(expression))];
    }
    /**
     * @param {?} options
     * @param {?} groupByProperty
     * @return {?}
     */
    virtualOptionsGroupingFlatten(options, groupByProperty) {
        /** @type {?} */
        const allParentGroupedValues = this.findUnique(options.filter((/**
         * @param {?} o
         * @return {?}
         */
        o => !o.parent)).map((/**
         * @param {?} item
         * @return {?}
         */
        item => item[groupByProperty])));
        /** @type {?} */
        const subGroupedValues = this.findUnique(options.filter((/**
         * @param {?} o
         * @return {?}
         */
        o => o.parent)).map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ name, parent }) => ({ name, parent }))));
        /** @type {?} */
        let result = [];
        allParentGroupedValues.forEach((/**
         * @param {?} group
         * @return {?}
         */
        group => {
            result.push({
                name: group,
                isGroup: true,
                ticked: this.allDescendantsAreTicked(options, groupByProperty, group),
                disabled: this.allDescendantsAreDisabled(options, groupByProperty, group)
            });
            /** @type {?} */
            const groupedValues = options
                .filter((/**
             * @param {?} o
             * @return {?}
             */
            o => o[groupByProperty] === group && !o.parent))
                .map((/**
             * @param {?} v
             * @return {?}
             */
            v => (Object.assign(Object.assign({}, v), { depth: 1 }))));
            result = [...result].concat(groupedValues);
            /** @type {?} */
            const childGroupedValues = subGroupedValues.filter((/**
             * @param {?} s
             * @return {?}
             */
            (s) => s.parent === group));
            childGroupedValues.forEach((/**
             * @param {?} c
             * @return {?}
             */
            c => {
                result.push({ name: c, parent: group, isGroup: true });
                /** @type {?} */
                const values = options.filter((/**
                 * @param {?} o
                 * @return {?}
                 */
                o => o[groupByProperty] === c)).map((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => (Object.assign(Object.assign({}, v), { depth: 2 }))));
                result.concat(values);
            }));
        }));
        return result;
    }
    /**
     * @param {?} json
     * @return {?}
     */
    mirrorObject(json) {
        /** @type {?} */
        const ret = {};
        for (var key in json) {
            ret[json[key]] = key;
        }
        return ret;
    }
    /**
     * @param {?} collection
     * @param {?} propertyMap
     * @param {?=} groupedProperty
     * @return {?}
     */
    mapDatasourceToFields(collection, propertyMap, groupedProperty) {
        /** @type {?} */
        let keys = Object.keys(propertyMap);
        return collection.map((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            /** @type {?} */
            let obj = groupedProperty ? { [groupedProperty]: item[groupedProperty] } : {};
            keys.reduce((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => {
                obj[b] = item[propertyMap[b]];
            }), obj);
            return obj;
        }));
    }
}
NgxMultiselectService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgxMultiselectService.ctorParameters = () => [];
/** @nocollapse */ NgxMultiselectService.ɵprov = ɵɵdefineInjectable({ factory: function NgxMultiselectService_Factory() { return new NgxMultiselectService(); }, token: NgxMultiselectService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: lib/filter-options/filter-options.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FilterOptionsComponent {
    constructor() {
        this.onSearchChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    clearInputFilter() {
        this.filterName.setValue('');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.filterName = new FormControl('');
        this.filterNameSubscription = this.filterName.valueChanges.subscribe((/**
         * @param {?} val
         * @return {?}
         */
        val => this.onSearchChange.emit(val)));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.filterNameSubscription.unsubscribe();
    }
}
FilterOptionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ms-filter-options',
                template: "<div class=\"input-search\">\n  <div class=\"field-infix\">\n    <input\n      autofocus\n      placeholder=\"Search options here..\"\n      type=\"text\"\n      [formControl]=\"filterName\"\n      ngDefaultControl\n      class=\"input-filter\"\n    />\n  </div>\n  <div class=\"field-suffix\">\n    <button type=\"button\" [disabled]=\"!filterName.value\" (click)=\"clearInputFilter()\" class=\"clear-button\">X</button>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".input-search{align-items:stretch;display:flex;flex-grow:1;height:30px;padding:2px}.mat-multiselect :host ::ng-deep .input-search{border-bottom:1px solid rgba(0,0,0,.12)}.mat-multiselect :host ::ng-deep .input-filter{border:none;flex-grow:1;font:inherit;outline:none}.mat-multiselect :host ::ng-deep .field-infix{display:flex;flex:1;padding:5px}.mat-multiselect :host ::ng-deep .field-suffix{margin:3px;white-space:nowrap}.mat-multiselect :host ::ng-deep .field-suffix button{border:none;border-radius:10px;font-size:inherit;height:20px;min-width:20px;padding:0;width:20px}.bs-multiselect :host ::ng-deep .clear-button{background-color:#f1f1f1;border:none;border-radius:2px;color:#666;cursor:pointer;font-size:inherit;max-width:20px;min-width:20px;padding:0}.bs-multiselect :host ::ng-deep .input-filter{border:1px solid #ccc;border-radius:2px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-sizing:border-box;color:#666;cursor:pointer;font-size:inherit;height:30px;height:100%;padding-left:7px;width:100%}.bs-multiselect :host ::ng-deep .field-infix{display:flex;flex-grow:1}.bs-multiselect :host ::ng-deep .field-suffix{display:flex}"]
            }] }
];
/** @nocollapse */
FilterOptionsComponent.ctorParameters = () => [];
FilterOptionsComponent.propDecorators = {
    onSearchChange: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    FilterOptionsComponent.prototype.filterName;
    /** @type {?} */
    FilterOptionsComponent.prototype.filterNameSubscription;
    /** @type {?} */
    FilterOptionsComponent.prototype.onSearchChange;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/multiselect.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NgxMultiselectComponent)),
    multi: true
};
class NgxMultiselectComponent {
    /**
     * @param {?} elementRef
     * @param {?} multiselectService
     */
    constructor(elementRef, multiselectService) {
        this.elementRef = elementRef;
        this.multiselectService = multiselectService;
        this._theme = 'material';
        this._isOpen = false;
        this.operationPendingQueue = [];
        // public variables
        this._selectedOptions = null;
        this._defaultPropertyMap = {
            id: 'id',
            name: 'name',
            disabled: 'disabled'
        };
        this._defaultPropertyMapLength = Object.keys(this._defaultPropertyMap).length;
        this.matMultiselect = true;
        this.bsMultiselect = false;
        // Input bindings
        this.disabled = false;
        this.color = 'blue';
        this.showHelperElements = true;
        this.showSearchFilter = true;
        this.showMaxLabels = 3;
        // Output bindings
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this.onItemClick = new EventEmitter();
        this.onGroupItemClick = new EventEmitter();
        this.onSelectAll = new EventEmitter();
        this.onSelectNone = new EventEmitter();
        this.onReset = new EventEmitter();
        this.onClear = new EventEmitter();
        this.onSearchChange = new EventEmitter();
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this.onTouched = (/**
         * @return {?}
         */
        () => { });
        this.filterOptionsList = (/**
         * @param {?} val
         * @return {?}
         */
        (val) => {
            /** @type {?} */
            const optionsCopy = this.getOptionsCopy();
            /** @type {?} */
            let result = optionsCopy;
            if (val) {
                result = optionsCopy.filter((/**
                 * @param {?} i
                 * @return {?}
                 */
                i => i.name && i.name.toLowerCase().indexOf(val.toLowerCase()) !== -1));
            }
            this.setOptions(result);
            this.prepopulateOptions(this._selectedOptions);
        });
    }
    /**
     * @return {?}
     */
    get optionsTemplate() {
        return this._optionsTemplate;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    set optionsTemplate(template) {
        this._optionsTemplate = template;
    }
    /**
     * @return {?}
     */
    get theme() {
        return this._theme;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set theme(val) {
        this._theme = val;
        this.matMultiselect = val === 'material';
        this.bsMultiselect = val === 'bootstrap';
    }
    // Input binding with getter / setter
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        this._isOpen = value;
        // onOpen and onClose event will be fired by isOpen setter
        if (value) {
            // list populate, based on empty value
            this.filterOptionsList('');
            this.onTouched();
            this.onOpen.emit();
        }
        else {
            this.onClose.emit();
        }
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set propertyMap(val) {
        this._defaultPropertyMap = Object.assign(Object.assign({}, this._defaultPropertyMap), val);
    }
    /**
     * @return {?}
     */
    get multiple() {
        return this._multiple;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set multiple(value) {
        this.viewToModel(value ? [] : null);
        this._multiple = value;
    }
    /**
     * @param {?} collection
     * @return {?}
     */
    set options(collection) {
        if (!collection)
            return;
        this._optionsCopy = this.multiselectService.mapDatasourceToFields(collection, this._defaultPropertyMap, this.groupedProperty);
        /** @type {?} */
        const options = this.getOptionsCopy();
        this.setOptions(options);
        // Sometimes binding can happens lazily, 
        // so `finishPendingOperations` helps to execute such operations
        if (this.isOperationPending())
            this.finishPendingOperations();
    }
    // Adding pending operation in queue
    /**
     * @param {?} item
     * @return {?}
     */
    addOperation(item) {
        this.operationPendingQueue.push(item);
    }
    // Poping pending operation from queue sequentially
    /**
     * @return {?}
     */
    popOperation() {
        return this.operationPendingQueue.pop();
    }
    /*
        In future this code is going to resides inside different Service,
        This pendingOperation feature is fine grained in future,
        and can be used for multiple purpose like model update, collection update, etc.
      */
    // Extracting and finishing all pending operation
    /**
     * @return {?}
     */
    finishPendingOperations() {
        /** @type {?} */
        const operation = this.popOperation();
        this.prepopulateOptions(operation);
    }
    // Check pending operation queue status
    /**
     * @return {?}
     */
    isOperationPending() {
        return this.operationPendingQueue.length;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set initialValue(value) {
        this._initialValue = value;
    }
    /**
     * @return {?}
     */
    get initialValue() {
        return this._initialValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        // Set selected value for initial load of value
        if (value) {
            this.initialValue = value;
            this._options ? this.prepopulateOptions(value) : this.addOperation(value);
            this.formatPrepopulatedValues(value);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    formatPrepopulatedValues(value) {
        /** @type {?} */
        let options = value;
        // TODO: can we improve below logic?
        if (Object.keys(this._defaultPropertyMap).length == this._defaultPropertyMapLength)
            return;
        /** @type {?} */
        const swappedPropertyMap = this.multiselectService.mirrorObject(this._defaultPropertyMap);
        if (this.multiple) {
            options.forEach((/**
             * @param {?} o
             * @return {?}
             */
            o => {
                o.id = o[swappedPropertyMap.id];
                o.name = o[swappedPropertyMap.name];
            }));
        }
        else {
            value.id = value[swappedPropertyMap.id];
            value.name = value[swappedPropertyMap.name];
            options = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    // All update to options should happen from below method.
    /**
     * @param {?} options
     * @return {?}
     */
    setOptions(options) {
        this._options = options;
    }
    /**
     * @return {?}
     */
    getOptions() {
        return this._options ? [...this._options] : [];
    }
    /**
     * @return {?}
     */
    getOptionsCopy() {
        return this._optionsCopy ? [...this._optionsCopy] : [];
    }
    /**
     * @return {?}
     */
    isValueSelected() {
        return this._selectedOptions && this._multiple ?
            this._selectedOptions.length :
            this._selectedOptions;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    searchChange(val) {
        this.filterOptionsList(val);
        this.onSearchChange.emit(val);
    }
    /**
     * @return {?}
     */
    close() {
        this.isOpen = false;
    }
    /**
     * @param {?} collection
     * @param {?} item
     * @return {?}
     */
    removeItem(collection, item) {
        item.ticked = false;
        /** @type {?} */
        const index = collection.findIndex((/**
         * @param {?} o
         * @return {?}
         */
        o => o.id === item.id));
        collection.splice(index, 1);
    }
    /**
     * @return {?}
     */
    toggleDropdown() {
        this.isOpen = !this.isOpen;
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    prepopulateOptions(selected) {
        /** @type {?} */
        let selectedIds = [];
        selectedIds = this._multiple ?
            (selected || []).map((/**
             * @param {?} i
             * @return {?}
             */
            i => i.id)) :
            selected ? [selected.id] : [];
        this.setOptions(this.getOptions()
            .map((/**
         * @param {?} o
         * @return {?}
         */
        o => (Object.assign(Object.assign({}, o), { ticked: selectedIds.indexOf(o.id) !== -1 })))));
        // TODO: do we really need this reassignment?
        this.viewToModel(selected);
    }
    /**
     * @param {?} option
     * @return {?}
     */
    select(option) {
        /** @type {?} */
        let selectedOptions;
        option.ticked = !option.ticked;
        // TODO: Refactor below logic
        if (this._multiple) {
            selectedOptions = [...this._selectedOptions];
            /** @type {?} */
            let selectedIds = selectedOptions.map((/**
             * @param {?} i
             * @return {?}
             */
            i => i.id));
            if (selectedIds.indexOf(option.id) === -1) {
                // if selected item not exist in collection, push it
                selectedOptions.push(option);
            }
            else {
                // if selected item exist in collection, post it
                this.removeItem(selectedOptions, option);
            }
            selectedIds = selectedOptions.map((/**
             * @param {?} i
             * @return {?}
             */
            i => i.id));
        }
        else {
            // TODO: find optimized way to do below
            /** @type {?} */
            let val = option && option.id;
            /** @type {?} */
            let changedOptions = this.getOptions()
                .map((/**
             * @param {?} o
             * @return {?}
             */
            o => (Object.assign(Object.assign({}, o), { ticked: o.id == val }))));
            selectedOptions = changedOptions.find((/**
             * @param {?} i
             * @return {?}
             */
            i => i.ticked));
            this.setOptions(changedOptions);
            this.close();
        }
        this.viewToModel(selectedOptions);
        this.onItemClick.emit(option);
    }
    /**
     * @return {?}
     */
    selectAll() {
        /** @type {?} */
        let allSelectedOptions = this.getOptions()
            .map((/**
         * @param {?} o
         * @return {?}
         */
        o => (Object.assign(Object.assign({}, o), { ticked: true }))));
        this.setOptions(allSelectedOptions);
        this.viewToModel(allSelectedOptions);
        this.onSelectAll.emit();
    }
    /**
     * @return {?}
     */
    selectNone() {
        /** @type {?} */
        const options = this.getOptions().map((/**
         * @param {?} o
         * @return {?}
         */
        o => (Object.assign(Object.assign({}, o), { ticked: false }))));
        this.setOptions(options);
        this.viewToModel([]);
        this.onSelectNone.emit();
    }
    /**
     * @return {?}
     */
    borderBottom() {
        return this._isOpen ? { borderBottom: `1px solid ${this.matMultiselect ? this.color : 'transperant'}` } : {};
    }
    //TODO: Optimized below logic, it can be done in lesser steps
    /**
     * @param {?} group
     * @return {?}
     */
    selectGroup(group) {
        const { ticked, values } = group;
        /** @type {?} */
        const options = this.getOptions();
        /** @type {?} */
        let selectedValues = [...this._selectedOptions];
        /** @type {?} */
        let selectedIds = selectedValues.map((/**
         * @param {?} s
         * @return {?}
         */
        s => s.id));
        /** @type {?} */
        const allGroupOptionIds = values.map((/**
         * @param {?} v
         * @return {?}
         */
        v => v.id));
        // Get all ticked options
        // concat with selected options
        selectedValues = ticked
            ? selectedValues.concat(values)
            : selectedValues.filter((/**
             * @param {?} o
             * @return {?}
             */
            o => allGroupOptionIds.indexOf(o.id) === -1));
        // Find unique out of them
        selectedIds = this.multiselectService.findUnique(selectedValues.map((/**
         * @param {?} item
         * @return {?}
         */
        item => item.id)));
        // build selectedOptions array again
        selectedValues = options.filter((/**
         * @param {?} o
         * @return {?}
         */
        o => selectedIds.indexOf(o.id) !== -1));
        this.viewToModel(selectedValues);
        this.onGroupItemClick.emit(group);
    }
    /**
     * @return {?}
     */
    reset() {
        this.viewToModel(this.initialValue);
        this.prepopulateOptions(this.initialValue);
        this.onReset.emit();
    }
    // Responsible for updating value from view to model
    /**
     * @param {?} selected
     * @return {?}
     */
    viewToModel(selected) {
        if (this._selectedOptions !== selected) {
            this._selectedOptions = selected;
            this.onChange(selected);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clear(event) {
        /** @type {?} */
        let changedOptions = this.getOptions().map((/**
         * @param {?} o
         * @return {?}
         */
        o => (Object.assign(Object.assign({}, o), { ticked: false }))));
        this.setOptions(changedOptions);
        // no value is selected so passing null
        this.viewToModel(null);
        this.onClear.emit();
        this.close();
        event.stopPropagation();
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Check if value have not been assigned then default to true
        if (typeof this._multiple === 'undefined') {
            this.multiple = true;
        }
    }
    // TODO: Consider creating a directive for this.
    // TODO: Also convert below to be work for element specific
    /**
     * @param {?} event
     * @return {?}
     */
    clickOutSide(event) {
        if (this.isOpen &&
            this.elementRef.nativeElement !== event &&
            !this.multiselectService.closest(event, 'ngx-multiselect')) {
            this.close();
        }
    }
}
NgxMultiselectComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-multiselect',
                template: "<div class=\"multiselect-wrapper\">\n  <button class=\"dropdown-button\" (click)=\"toggleDropdown()\" [ngClass]=\"{ open: isOpen }\">\n    <div class=\"selection\" [ngStyle]=\"borderBottom()\">\n      <!-- TODO: None selected template should be ng-template -->\n      <span class=\"none-selected\" *ngIf=\"!isValueSelected()\">None selected</span>\n      <span class=\"selected\" *ngIf=\"isValueSelected()\">\n        <span class=\"text\">{{_selectedOptions | displaySelectedValue: showMaxLabels}}</span>\n      </span>\n      <div class=\"symbols\">\n        <span class=\"close\" (click)=\"clear($event)\" *ngIf=\"isValueSelected() && !multiple\">\u00D7</span>\n        <span class=\"caret\"></span>\n      </div>\n    </div>\n  </button>\n  <div class=\"listing-wrapper\" *ngIf=\"isOpen\">\n    <ms-helper-elements\n      *ngIf=\"showHelperElements\"\n      [multiple]=\"multiple\"\n      [disabled]=\"disabled\"\n      (onClear)=\"onClear.emit()\"\n      (resetClicked)=\"reset()\"\n      (onSearchChange)=\"onSearchChange.emit($event)\"\n      (selectNoneClicked)=\"selectNone()\"\n      (selectAllClicked)=\"selectAll()\"\n      (selectNoneClicked)=\"selectNone()\"\n    >\n    </ms-helper-elements>\n    <ms-filter-options\n      *ngIf=\"showSearchFilter\"\n      #filterOptions\n      (onSearchChange)=\"searchChange($event)\"\n    ></ms-filter-options>\n    <ng-container *ngIf=\"!groupedProperty; else groupedTemplate\">\n      <ms-options\n        [optionsTemplate]=\"optionsTemplate\"\n        [options]=\"_options\"\n        [disabled]=\"disabled\"\n        (selectOption)=\"select($event)\"\n      ></ms-options>\n    </ng-container>\n  </div>\n</div>\n<ng-template #groupedTemplate>\n  <ms-grouped-options\n    [multiple]=\"multiple\"\n    [optionsTemplate]=\"optionsTemplate\"\n    [selectedOptions]=\"_selectedOptions\"\n    [options]=\"_options\"\n    [disabled]=\"disabled\"\n    [groupedProperty]=\"groupedProperty\"\n    (selectOption)=\"select($event)\"\n    (selectGroup)=\"selectGroup($event)\"\n  >\n  </ms-grouped-options>\n</ng-template>\n",
                providers: [DEFAULT_VALUE_ACCESSOR],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:inline-block;outline:none}.multiselect-wrapper{display:flex;flex-grow:1;width:240px}.selection{flex-grow:1;justify-content:space-between}.selection,.symbols{align-items:center;display:flex}.symbols{justify-content:flex-end}.symbols .caret{border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid}.dropdown-button{-moz-user-select:none;-ms-user-select:none;-o-user-select:none;-webkit-user-select:none;background-color:#fff;border:none;cursor:pointer;display:flex;flex-grow:1;font-size:inherit;min-height:39px;padding:5px;user-select:none;white-space:normal}.listing-wrapper{background-color:#fff;border:1px solid rgba(0,0,0,.15);border-radius:4px;box-shadow:0 6px 12px rgba(0,0,0,.175);position:absolute;width:inherit;z-index:999}::ng-deep .options-container{height:200px;overflow-y:scroll}:host.mat-multiselect ::ng-deep .option{-webkit-tap-highlight-color:transparent;align-items:center;border-left:.5px solid #eee;display:flex;flex-flow:row;height:40px;max-height:40px;outline:0;overflow:hidden;padding:0 6px;text-overflow:ellipsis;white-space:nowrap}:host.mat-multiselect ::ng-deep .option.marked,:host.mat-multiselect ::ng-deep .option.marked:hover,:host.mat-multiselect ::ng-deep .option:hover:not(.message){background-image:linear-gradient(#e9e9e9,#f1f1f1);color:#555;cursor:pointer;justify-content:space-between}:host.mat-multiselect ::ng-deep .marked:after{content:\"\u2713\"}:host.mat-multiselect ::ng-deep .option.disabled,:host.mat-multiselect ::ng-deep .option.disabled:hover:not(.message),:host.mat-multiselect ::ng-deep .option.disabled label input:hover~span{color:#c4c4c4!important;cursor:not-allowed!important;pointer-events:none}:host.mat-multiselect ::ng-deep .none-selected{-webkit-text-fill-color:#7a7a7a;color:#7a7a7a;transition:none}:host.mat-multiselect ::ng-deep .dropdown-button{color:#000}:host.mat-multiselect ::ng-deep .selection{border-bottom:1px solid #000;color:#000;padding-bottom:10px}:host.mat-multiselect ::ng-deep .open .selection{border-bottom:1px solid #00f}:host.bs-multiselect ::ng-deep .marked{background-color:green}:host.bs-multiselect ::ng-deep .dropdown-button{background-image:linear-gradient(#fff,#f7f7f7);border:1px solid #c6c6c6;border-radius:4px;color:#555}:host.bs-multiselect ::ng-deep .option{align-items:center;background-color:transparent;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);color:#555;display:flex;font-size:inherit;height:40px;max-height:40px;padding:0 6px}:host.bs-multiselect ::ng-deep .option:hover{background-image:linear-gradient(#c1c1c1,#999)!important;color:#fff!important;cursor:pointer}:host.bs-multiselect ::ng-deep .option.marked{background-image:linear-gradient(#e9e9e9,#f1f1f1);color:#555;cursor:pointer;display:flex;justify-content:space-between}:host.bs-multiselect ::ng-deep .marked:after{content:\"\u2713\";width:15px}:host.bs-multiselect ::ng-deep .option.disabled,:host.bs-multiselect ::ng-deep .option.disabled:hover,:host.bs-multiselect ::ng-deep .option.disabled label input:hover~span{color:#c4c4c4!important;cursor:not-allowed!important;pointer-events:none}"]
            }] }
];
/** @nocollapse */
NgxMultiselectComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgxMultiselectService }
];
NgxMultiselectComponent.propDecorators = {
    matMultiselect: [{ type: HostBinding, args: ['class.mat-multiselect',] }],
    bsMultiselect: [{ type: HostBinding, args: ['class.bs-multiselect',] }],
    disabled: [{ type: Input }],
    color: [{ type: Input }],
    groupedProperty: [{ type: Input }],
    showHelperElements: [{ type: Input }],
    showSearchFilter: [{ type: Input }],
    showMaxLabels: [{ type: Input }],
    _optionsTemplate: [{ type: ContentChild, args: [TemplateRef,] }],
    optionsTemplate: [{ type: Input }],
    theme: [{ type: Input }],
    isOpen: [{ type: Input }],
    propertyMap: [{ type: Input }],
    multiple: [{ type: Input }],
    options: [{ type: Input }],
    onOpen: [{ type: Output }],
    onClose: [{ type: Output }],
    onItemClick: [{ type: Output }],
    onGroupItemClick: [{ type: Output }],
    onSelectAll: [{ type: Output }],
    onSelectNone: [{ type: Output }],
    onReset: [{ type: Output }],
    onClear: [{ type: Output }],
    onSearchChange: [{ type: Output }],
    filterOptions: [{ type: ViewChild, args: ['filterOptions', { read: FilterOptionsComponent },] }],
    clickOutSide: [{ type: HostListener, args: ['document:click', ['$event.target'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._multiple;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._theme;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._optionsCopy;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._isOpen;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype.operationPendingQueue;
    /** @type {?} */
    NgxMultiselectComponent.prototype._selectedOptions;
    /** @type {?} */
    NgxMultiselectComponent.prototype._defaultPropertyMap;
    /** @type {?} */
    NgxMultiselectComponent.prototype._defaultPropertyMapLength;
    /** @type {?} */
    NgxMultiselectComponent.prototype._options;
    /** @type {?} */
    NgxMultiselectComponent.prototype.matMultiselect;
    /** @type {?} */
    NgxMultiselectComponent.prototype.bsMultiselect;
    /** @type {?} */
    NgxMultiselectComponent.prototype.disabled;
    /** @type {?} */
    NgxMultiselectComponent.prototype.color;
    /** @type {?} */
    NgxMultiselectComponent.prototype.groupedProperty;
    /** @type {?} */
    NgxMultiselectComponent.prototype.showHelperElements;
    /** @type {?} */
    NgxMultiselectComponent.prototype.showSearchFilter;
    /** @type {?} */
    NgxMultiselectComponent.prototype.showMaxLabels;
    /** @type {?} */
    NgxMultiselectComponent.prototype._optionsTemplate;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onOpen;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onClose;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onItemClick;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onGroupItemClick;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onSelectAll;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onSelectNone;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onReset;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onClear;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onSearchChange;
    /** @type {?} */
    NgxMultiselectComponent.prototype.filterOptions;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._initialValue;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onChange;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onTouched;
    /** @type {?} */
    NgxMultiselectComponent.prototype.filterOptionsList;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype.multiselectService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/display-selected-value.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DOTS = ' ...';
class DisplaySelectedValuePipe {
    constructor() {
        this.defaultMaxLabelCount = 3;
    }
    /**
     * @param {?} value
     * @param {?=} maxLabelCount
     * @return {?}
     */
    transform(value, maxLabelCount = this.defaultMaxLabelCount) {
        if (value instanceof Array) {
            /** @type {?} */
            const collection = [...value];
            /** @type {?} */
            var total = collection.length;
            /** @type {?} */
            const condn = collection.length > maxLabelCount;
            condn ? (collection.length = maxLabelCount) : null;
            return `${collection.map((/**
             * @param {?} v
             * @return {?}
             */
            v => v.name)).join(', ')}${condn ? DOTS + ' (' + total + ')' : ''}`;
        }
        return value && value.name;
    }
}
DisplaySelectedValuePipe.decorators = [
    { type: Pipe, args: [{
                name: 'displaySelectedValue',
                pure: false
            },] }
];
if (false) {
    /** @type {?} */
    DisplaySelectedValuePipe.prototype.defaultMaxLabelCount;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/helper-elements/helper-elements.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HelperElementsComponent {
    constructor() {
        this.multiple = false;
        this.disabled = false;
        this.selectAllClicked = new EventEmitter();
        this.selectNoneClicked = new EventEmitter();
        this.resetClicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    selectAll() {
        this.selectAllClicked.emit();
    }
    /**
     * @return {?}
     */
    selectNone() {
        this.selectNoneClicked.emit();
    }
    /**
     * @return {?}
     */
    reset() {
        this.resetClicked.emit();
    }
}
HelperElementsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ms-helper-elements',
                template: "<div class=\"helper-buttons\">\n  <fieldset [disabled]=\"disabled\">\n    <ng-container *ngIf=\"multiple\">\n      <button class=\"helper-button\" (click)=\"selectAll()\">\u2713 Select All</button>\n      <button class=\"helper-button\" (click)=\"selectNone()\">\u00D7 Select None</button>\n    </ng-container>\n    <button class=\"helper-button\" (click)=\"reset()\">\u21B6 Reset</button>\n  </fieldset>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".helper-button{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;border:1px solid rgba(0,0,0,.12);border-radius:.25rem;font-size:.75rem;font-weight:400;height:30px;max-height:30px;user-select:none;white-space:nowrap}fieldset{border:none;padding:0}.helper-buttons{border-bottom:1px solid #ddd;padding:2px}.mat-multiselect :host .helper-button{background-color:transparent;color:#444}.mat-multiselect :host .helper-button:not(:last-child){margin:0 2px}.bs-multiselect :host .helper-button{-webkit-tap-highlight-color:transparent;box-sizing:border-box;cursor:pointer;outline:0;padding:.25em}.bs-multiselect .helper-button:not(:last-child){margin-right:4px}"]
            }] }
];
/** @nocollapse */
HelperElementsComponent.ctorParameters = () => [];
HelperElementsComponent.propDecorators = {
    multiple: [{ type: Input }],
    disabled: [{ type: Input }],
    selectAllClicked: [{ type: Output }],
    selectNoneClicked: [{ type: Output }],
    resetClicked: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    HelperElementsComponent.prototype.multiple;
    /** @type {?} */
    HelperElementsComponent.prototype.disabled;
    /** @type {?} */
    HelperElementsComponent.prototype.selectAllClicked;
    /** @type {?} */
    HelperElementsComponent.prototype.selectNoneClicked;
    /** @type {?} */
    HelperElementsComponent.prototype.resetClicked;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/options/options.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OptionsComponent {
    constructor() {
        this._options = [];
        this.disabled = false;
        this.selectOption = new EventEmitter();
        this.start = 0;
        this.end = 5;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set options(value) {
        this._options = value;
    }
    /**
     * @return {?}
     */
    get() {
        return this._options;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    getOptionStyle(option) {
        return { marked: option.ticked, disabled: this.disabled || option.disabled };
    }
    /**
     * @param {?} option
     * @return {?}
     */
    select(option) {
        this.selectOption.emit(option);
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    updateRange({ start, end }) {
        this.filteredOptions = [...this._options].slice(start, end);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const { options } = changes;
        if (!this.optionsTemplate) {
            this.optionsTemplate = this.defaultOptionsTemplate;
        }
        if (options.currentValue !== options.previousValue) {
            this.updateRange({ start: this.start, end: this.end });
        }
    }
}
OptionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ms-options',
                template: "<div class=\"options-container\" msVirtualScroll [totalCount]=\"_options?.length\" (rangeChanged)=\"updateRange($event)\">\n  <div #top class=\"top\"></div>\n  <ng-container *ngIf=\"filteredOptions.length; else noOptions\">\n    <div\n      class=\"option\"\n      [ngClass]=\"getOptionStyle(option)\"\n      *ngFor=\"let option of filteredOptions\"\n      (click)=\"select(option)\"\n    >\n      <ng-container\n        *ngTemplateOutlet=\"\n          optionsTemplate;\n          context: {\n            option: option\n          }\n        \"\n      ></ng-container>\n    </div>\n  </ng-container>\n  <div #bottom class=\"bottom\"></div>\n</div>\n<ng-template #defaultOptionsTemplate let-option=\"option\">\n  {{ option.name }}\n</ng-template>\n<ng-template #noOptions let-option=\"option\">\n  <div class=\"option message\">\n    No options available.\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            }] }
];
/** @nocollapse */
OptionsComponent.ctorParameters = () => [];
OptionsComponent.propDecorators = {
    disabled: [{ type: Input }],
    options: [{ type: Input }],
    optionsTemplate: [{ type: Input }],
    selectOption: [{ type: Output }],
    defaultOptionsTemplate: [{ type: ViewChild, args: ['defaultOptionsTemplate', { static: true },] }]
};
if (false) {
    /** @type {?} */
    OptionsComponent.prototype._options;
    /** @type {?} */
    OptionsComponent.prototype.disabled;
    /** @type {?} */
    OptionsComponent.prototype.optionsTemplate;
    /** @type {?} */
    OptionsComponent.prototype.selectOption;
    /** @type {?} */
    OptionsComponent.prototype.start;
    /** @type {?} */
    OptionsComponent.prototype.end;
    /** @type {?} */
    OptionsComponent.prototype.filteredOptions;
    /** @type {?} */
    OptionsComponent.prototype.defaultOptionsTemplate;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/grouped-options/grouped-options.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GroupedOptionsComponent {
    /**
     * @param {?} multiselectService
     */
    constructor(multiselectService) {
        this.multiselectService = multiselectService;
        this._options = [];
        this._selectedOptions = [];
        this.groupedOptions = [];
        this.start = 0;
        this.end = 5;
        this.disabled = false;
        this.multiple = false;
        this.selectGroup = new EventEmitter();
        this.selectOption = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedOptions(value) {
        this._selectedOptions = value;
        this.formGroupOptions(this._options, this._selectedOptions);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set options(value) {
        this._options = value;
        this.formGroupOptions(value, this._selectedOptions);
    }
    /**
     * @return {?}
     */
    get options() {
        return this.groupedOptions;
    }
    // TODO: Refactor below logic
    /**
     * @param {?} collection
     * @param {?} selectedOptions
     * @return {?}
     */
    formGroupOptions(collection, selectedOptions) {
        /** @type {?} */
        let selectedIds = this.multiple ?
            (selectedOptions || []).map((/**
             * @param {?} s
             * @return {?}
             */
            s => s.id)) :
            selectedOptions ? [selectedOptions.id]
                : [];
        /** @type {?} */
        const values = collection.map((/**
         * @param {?} v
         * @return {?}
         */
        v => (Object.assign(Object.assign({}, v), { ticked: !v.isGroup ? selectedIds.indexOf(v.id) !== -1 : v.ticked }))));
        this.groupedOptions = this.multiselectService.virtualOptionsGroupingFlatten(values, this.groupedProperty);
        this.updateRange({ start: this.start, end: this.end });
    }
    /**
     * @param {?} option
     * @return {?}
     */
    getOptionStyle(option) {
        return {
            group: option.isGroup,
            marked: option.ticked,
            disabled: this.disabled || option.disabled
        };
    }
    /**
     * @param {?} _
     * @param {?} option
     * @return {?}
     */
    trackByFn(_, option) {
        return option.id;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    updateRange({ start, end }) {
        this.start = start;
        this.end = end;
        this.filteredOptions = [...this.options].slice(start, end);
    }
    /**
     * @param {?} option
     * @return {?}
     */
    select(option) {
        if (!option.isGroup) {
            this.selectOption.emit(option);
        }
        else {
            option.ticked = !option.ticked;
            /** @type {?} */
            const values = this.multiselectService.collectAllDescendants(this.options, this.groupedProperty, option.name);
            this.selectGroup.emit(Object.assign(Object.assign({}, option), { values: values }));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (!this.optionsTemplate) {
            this.optionsTemplate = this.defaultOptionsTemplate;
        }
    }
}
GroupedOptionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ms-grouped-options',
                template: "<div class=\"options-container\" msVirtualScroll [totalCount]=\"options.length\" (rangeChanged)=\"updateRange($event)\">\n  <div #top class=\"top\"></div>\n  <ng-container *ngIf=\"filteredOptions.length; else noOptions\">\n    <div\n      class=\"option\"\n      [ngStyle]=\"{ marginLeft: option.depth * 15 + 'px' }\"\n      [ngClass]=\"getOptionStyle(option)\"\n      *ngFor=\"let option of filteredOptions; trackBy: trackByFn\"\n      (click)=\"select(option)\"\n    >\n      <ng-container\n        *ngTemplateOutlet=\"\n          optionsTemplate;\n          context: {\n            option: option\n          }\n        \"\n      ></ng-container>\n    </div>\n  </ng-container>\n  <div #bottom class=\"bottom\"></div>\n</div>\n<ng-template #defaultOptionsTemplate let-option=\"option\">\n  {{ option?.name }}\n</ng-template>\n<ng-template #noOptions let-option=\"option\">\n  <div class=\"option message\">\n    No options available.\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            }] }
];
/** @nocollapse */
GroupedOptionsComponent.ctorParameters = () => [
    { type: NgxMultiselectService }
];
GroupedOptionsComponent.propDecorators = {
    groupedProperty: [{ type: Input }],
    disabled: [{ type: Input }],
    multiple: [{ type: Input }],
    selectedOptions: [{ type: Input }],
    optionsTemplate: [{ type: Input }],
    options: [{ type: Input }],
    selectGroup: [{ type: Output }],
    selectOption: [{ type: Output }],
    defaultOptionsTemplate: [{ type: ViewChild, args: ['defaultOptionsTemplate', { static: true },] }]
};
if (false) {
    /** @type {?} */
    GroupedOptionsComponent.prototype._options;
    /** @type {?} */
    GroupedOptionsComponent.prototype._selectedOptions;
    /** @type {?} */
    GroupedOptionsComponent.prototype.groupedOptions;
    /** @type {?} */
    GroupedOptionsComponent.prototype.start;
    /** @type {?} */
    GroupedOptionsComponent.prototype.end;
    /** @type {?} */
    GroupedOptionsComponent.prototype.filteredOptions;
    /** @type {?} */
    GroupedOptionsComponent.prototype.groupedProperty;
    /** @type {?} */
    GroupedOptionsComponent.prototype.disabled;
    /** @type {?} */
    GroupedOptionsComponent.prototype.multiple;
    /** @type {?} */
    GroupedOptionsComponent.prototype.optionsTemplate;
    /** @type {?} */
    GroupedOptionsComponent.prototype.selectGroup;
    /** @type {?} */
    GroupedOptionsComponent.prototype.selectOption;
    /** @type {?} */
    GroupedOptionsComponent.prototype.defaultOptionsTemplate;
    /** @type {?} */
    GroupedOptionsComponent.prototype.multiselectService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/virtual-scroll.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VirtualScrollDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.scrollOffset = 0;
        this.itemHeight = 40;
        this.rangeChanged = new EventEmitter();
        this.lastScrollFireTime = 0;
    }
    /**
     * @param {?} count
     * @return {?}
     */
    set totalCount(count) {
        this._totalCount = count;
        count ? this.initialSetup() : this.reset();
    }
    /**
     * @return {?}
     */
    get() {
        return this._totalCount;
    }
    /**
     * @return {?}
     */
    reset() {
        if (this.top && this.bottom) {
            this.renderer.setStyle(this.top, 'height', 0);
            this.renderer.setStyle(this.bottom, 'height', 0);
            this.renderer.setProperty(this.el.nativeElement, 'scrollTop', 0);
        }
    }
    /**
     * @param {?} target
     * @return {?}
     */
    throttleScroll(target) {
        const { scrollTop, clientHeight } = target;
        /** @type {?} */
        const totalHeight = this.itemHeight * this._totalCount + this.scrollOffset;
        // Step: 1 - Calculate the position
        /** @type {?} */
        const topSpacing = scrollTop;
        /** @type {?} */
        const maxItemsRange = (clientHeight - this.scrollOffset) / this.itemHeight;
        // Step: 2 - What are the possible collection that can be rendered
        /** @type {?} */
        const rangeOffset = topSpacing % this.itemHeight;
        /** @type {?} */
        const rangeStart = topSpacing - rangeOffset;
        /** @type {?} */
        const topNonVisible = topSpacing / this.itemHeight;
        /** @type {?} */
        const itemStartRange = Math.floor(topNonVisible);
        /** @type {?} */
        const rangeToBeIncreamented = rangeOffset ? maxItemsRange + 1 : maxItemsRange;
        /** @type {?} */
        const calculatedEndRange = itemStartRange + rangeToBeIncreamented;
        /** @type {?} */
        const itemEndRange = calculatedEndRange >= this._totalCount ? this._totalCount : calculatedEndRange;
        /** @type {?} */
        const bottomSpacing = totalHeight - (rangeStart + rangeToBeIncreamented * this.itemHeight);
        // Step: 3 - Pass the range to the child directive
        this.renderer.setStyle(this.top, 'height', `${rangeStart}px`);
        this.renderer.setStyle(this.bottom, 'height', `${bottomSpacing}px`);
        this.rangeChanged.emit({ start: itemStartRange, end: itemEndRange });
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    onscroll({ target }) {
        /** @type {?} */
        const minScrollTime = 50;
        /** @type {?} */
        const now = new Date().getTime();
        if (!this.scrollTimer) {
            if (now - this.lastScrollFireTime > minScrollTime) {
                this.lastScrollFireTime = now;
            }
            this.scrollTimer = setTimeout((/**
             * @return {?}
             */
            () => {
                this.scrollTimer = null;
                this.lastScrollFireTime = new Date().getTime();
                this.throttleScroll(target);
            }), minScrollTime);
        }
    }
    /**
     * @return {?}
     */
    initialSetup() {
        // TODO: later think of usng ViewChild, instead of direct DOM manipulation.
        const { scrollTop, clientHeight } = this.el.nativeElement;
        this.top = this.renderer.selectRootElement('.top');
        this.bottom = this.renderer.selectRootElement('.bottom');
        this.renderer.setStyle(this.top, 'height', `${scrollTop}px`);
        this.renderer.setStyle(this.bottom, 'height', `${this.itemHeight * this._totalCount + this.scrollOffset - clientHeight}px`);
        this.renderer.setProperty(this.el.nativeElement, 'scrollTop', 0);
    }
}
VirtualScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[msVirtualScroll]'
            },] }
];
/** @nocollapse */
VirtualScrollDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
VirtualScrollDirective.propDecorators = {
    itemHeight: [{ type: Input }],
    totalCount: [{ type: Input }],
    rangeChanged: [{ type: Output }],
    onscroll: [{ type: HostListener, args: ['scroll', ['$event'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype._totalCount;
    /** @type {?} */
    VirtualScrollDirective.prototype.top;
    /** @type {?} */
    VirtualScrollDirective.prototype.bottom;
    /** @type {?} */
    VirtualScrollDirective.prototype.scrollOffset;
    /** @type {?} */
    VirtualScrollDirective.prototype.itemHeight;
    /** @type {?} */
    VirtualScrollDirective.prototype.rangeChanged;
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype.scrollTimer;
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype.lastScrollFireTime;
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype.renderer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/multiselect.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMultiselectModule {
}
NgxMultiselectModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ReactiveFormsModule],
                declarations: [
                    NgxMultiselectComponent,
                    DisplaySelectedValuePipe,
                    HelperElementsComponent,
                    FilterOptionsComponent,
                    OptionsComponent,
                    GroupedOptionsComponent,
                    VirtualScrollDirective
                ],
                exports: [NgxMultiselectComponent, DisplaySelectedValuePipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-lib-multiselect.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DEFAULT_VALUE_ACCESSOR, DisplaySelectedValuePipe, FilterOptionsComponent, GroupedOptionsComponent, HelperElementsComponent, NgxMultiselectComponent, NgxMultiselectModule, NgxMultiselectService, OptionsComponent, VirtualScrollDirective as ɵa };
//# sourceMappingURL=ngx-lib-multiselect.js.map
