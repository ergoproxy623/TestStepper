import { Injectable, ɵɵdefineInjectable, EventEmitter, Component, ChangeDetectionStrategy, Output, forwardRef, ElementRef, HostBinding, Input, ContentChild, TemplateRef, ViewChild, HostListener, Pipe, Directive, Renderer2, NgModule } from '@angular/core';
import { FormControl, NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/multiselect.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/forms';
import * as ɵngcc2 from '@angular/common';

const _c0 = ["filterOptions"];
function NgxMultiselectComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 10);
    ɵngcc0.ɵɵtext(1, "None selected");
    ɵngcc0.ɵɵelementEnd();
} }
function NgxMultiselectComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 11);
    ɵngcc0.ɵɵelementStart(1, "span", 12);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵpipe(3, "displaySelectedValue");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind2(3, 1, ctx_r1._selectedOptions, ctx_r1.showMaxLabels));
} }
function NgxMultiselectComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 13);
    ɵngcc0.ɵɵlistener("click", function NgxMultiselectComponent_span_6_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.clear($event); });
    ɵngcc0.ɵɵtext(1, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
} }
function NgxMultiselectComponent_div_8_ms_helper_elements_1_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ms-helper-elements", 18);
    ɵngcc0.ɵɵlistener("onClear", function NgxMultiselectComponent_div_8_ms_helper_elements_1_Template_ms_helper_elements_onClear_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.onClear.emit(); })("resetClicked", function NgxMultiselectComponent_div_8_ms_helper_elements_1_Template_ms_helper_elements_resetClicked_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.reset(); })("onSearchChange", function NgxMultiselectComponent_div_8_ms_helper_elements_1_Template_ms_helper_elements_onSearchChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onSearchChange.emit($event); })("selectNoneClicked", function NgxMultiselectComponent_div_8_ms_helper_elements_1_Template_ms_helper_elements_selectNoneClicked_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.selectNone(); })("selectAllClicked", function NgxMultiselectComponent_div_8_ms_helper_elements_1_Template_ms_helper_elements_selectAllClicked_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.selectAll(); })("selectNoneClicked", function NgxMultiselectComponent_div_8_ms_helper_elements_1_Template_ms_helper_elements_selectNoneClicked_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r17 = ɵngcc0.ɵɵnextContext(2); return ctx_r17.selectNone(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("multiple", ctx_r8.multiple)("disabled", ctx_r8.disabled);
} }
function NgxMultiselectComponent_div_8_ms_filter_options_2_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ms-filter-options", 19, 20);
    ɵngcc0.ɵɵlistener("onSearchChange", function NgxMultiselectComponent_div_8_ms_filter_options_2_Template_ms_filter_options_onSearchChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r19 = ɵngcc0.ɵɵnextContext(2); return ctx_r19.searchChange($event); });
    ɵngcc0.ɵɵelementEnd();
} }
function NgxMultiselectComponent_div_8_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "ms-options", 21);
    ɵngcc0.ɵɵlistener("selectOption", function NgxMultiselectComponent_div_8_ng_container_3_Template_ms_options_selectOption_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r21 = ɵngcc0.ɵɵnextContext(2); return ctx_r21.select($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("optionsTemplate", ctx_r10.optionsTemplate)("options", ctx_r10._options)("disabled", ctx_r10.disabled);
} }
function NgxMultiselectComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(1, NgxMultiselectComponent_div_8_ms_helper_elements_1_Template, 1, 2, "ms-helper-elements", 15);
    ɵngcc0.ɵɵtemplate(2, NgxMultiselectComponent_div_8_ms_filter_options_2_Template, 2, 0, "ms-filter-options", 16);
    ɵngcc0.ɵɵtemplate(3, NgxMultiselectComponent_div_8_ng_container_3_Template, 2, 3, "ng-container", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    const _r4 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showHelperElements);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showSearchFilter);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r3.groupedProperty)("ngIfElse", _r4);
} }
function NgxMultiselectComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    const _r24 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ms-grouped-options", 22);
    ɵngcc0.ɵɵlistener("selectOption", function NgxMultiselectComponent_ng_template_9_Template_ms_grouped_options_selectOption_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r24); const ctx_r23 = ɵngcc0.ɵɵnextContext(); return ctx_r23.select($event); })("selectGroup", function NgxMultiselectComponent_ng_template_9_Template_ms_grouped_options_selectGroup_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r24); const ctx_r25 = ɵngcc0.ɵɵnextContext(); return ctx_r25.selectGroup($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("multiple", ctx_r5.multiple)("optionsTemplate", ctx_r5.optionsTemplate)("selectedOptions", ctx_r5._selectedOptions)("options", ctx_r5._options)("disabled", ctx_r5.disabled)("groupedProperty", ctx_r5.groupedProperty);
} }
const _c1 = function (a0) { return { open: a0 }; };
function HelperElementsComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 3);
    ɵngcc0.ɵɵlistener("click", function HelperElementsComponent_ng_container_2_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.selectAll(); });
    ɵngcc0.ɵɵtext(2, "\u2713 Select All");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "button", 3);
    ɵngcc0.ɵɵlistener("click", function HelperElementsComponent_ng_container_2_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.selectNone(); });
    ɵngcc0.ɵɵtext(4, "\u00D7 Select None");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} }
const _c2 = ["defaultOptionsTemplate"];
function OptionsComponent_ng_container_3_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c3 = function (a0) { return { option: a0 }; };
function OptionsComponent_ng_container_3_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵlistener("click", function OptionsComponent_ng_container_3_div_1_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const option_r8 = ctx.$implicit; const ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.select(option_r8); });
    ɵngcc0.ɵɵtemplate(1, OptionsComponent_ng_container_3_div_1_ng_container_1_Template, 1, 0, "ng-container", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r8 = ctx.$implicit;
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r7.getOptionStyle(option_r8));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r7.optionsTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(3, _c3, option_r8));
} }
function OptionsComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, OptionsComponent_ng_container_3_div_1_Template, 2, 5, "div", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.filteredOptions);
} }
function OptionsComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const option_r12 = ctx.option;
    ɵngcc0.ɵɵtextInterpolate1(" ", option_r12.name, "\n");
} }
function OptionsComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtext(1, " No options available. ");
    ɵngcc0.ɵɵelementEnd();
} }
function GroupedOptionsComponent_ng_container_3_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c4 = function (a0) { return { marginLeft: a0 }; };
function GroupedOptionsComponent_ng_container_3_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵlistener("click", function GroupedOptionsComponent_ng_container_3_div_1_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const option_r8 = ctx.$implicit; const ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.select(option_r8); });
    ɵngcc0.ɵɵtemplate(1, GroupedOptionsComponent_ng_container_3_div_1_ng_container_1_Template, 1, 0, "ng-container", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r8 = ctx.$implicit;
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(4, _c4, option_r8.depth * 15 + "px"))("ngClass", ctx_r7.getOptionStyle(option_r8));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r7.optionsTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c3, option_r8));
} }
function GroupedOptionsComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, GroupedOptionsComponent_ng_container_3_div_1_Template, 2, 8, "div", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.filteredOptions)("ngForTrackBy", ctx_r1.trackByFn);
} }
function GroupedOptionsComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const option_r12 = ctx.option;
    ɵngcc0.ɵɵtextInterpolate1(" ", option_r12 == null ? null : option_r12.name, "\n");
} }
function GroupedOptionsComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtext(1, " No options available. ");
    ɵngcc0.ɵɵelementEnd();
} }
const matchSelectors = [
    'matches',
    'webkitMatchesSelector',
    'mozMatchesSelector',
    'msMatchesSelector',
    'oMatchesSelector'
];
class NgxMultiselectService {
    constructor() { }
    /**
     * @param {?} node
     * @param {?} selector
     * @return {?}
     */
    pseudoClassExist(node, selector) {
        /** @type {?} */
        const nativeMatches = node.matches || node.msMatchesSelector;
        try {
            return nativeMatches.call(node, selector);
        }
        catch (error) {
            return false;
        }
    }
    /**
     * @param {?} el
     * @param {?} selector
     * @return {?}
     */
    closest(el, selector) {
        /** @type {?} */
        let matchesFn;
        // find vendor prefix
        matchSelectors.some((/**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (typeof document.body[fn] === 'function') {
                matchesFn = fn;
                return true;
            }
            return false;
        }));
        /** @type {?} */
        let parent;
        // traverse parents
        while (el) {
            parent = el.parentElement;
            if (parent && parent[matchesFn](selector)) {
                return parent;
            }
            el = parent;
        }
        return false;
    }
    // TODO: make this logic to work to find all descendant groups
    /**
     * @param {?} collection
     * @param {?} groupProperty
     * @param {?} groupName
     * @return {?}
     */
    collectAllDescendants(collection, groupProperty, groupName) {
        /** @type {?} */
        const allDescendants = collection.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => item[groupProperty] == groupName));
        allDescendants.concat(collection.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => item.parent == groupName)));
        return allDescendants;
    }
    /**
     * @private
     * @param {?} collection
     * @param {?} groupProperty
     * @param {?} groupName
     * @return {?}
     */
    allDescendantsAreTicked(collection, groupProperty, groupName) {
        /** @type {?} */
        const allDescendants = this.collectAllDescendants(collection, groupProperty, groupName);
        /** @type {?} */
        const allAreTicked = allDescendants.every((/**
         * @param {?} d
         * @return {?}
         */
        d => d.ticked));
        return allAreTicked;
    }
    /**
     * @private
     * @param {?} collection
     * @param {?} groupProperty
     * @param {?} groupName
     * @return {?}
     */
    allDescendantsAreDisabled(collection, groupProperty, groupName) {
        /** @type {?} */
        const allDescendants = this.collectAllDescendants(collection, groupProperty, groupName);
        /** @type {?} */
        const allAreDisabled = allDescendants.every((/**
         * @param {?} d
         * @return {?}
         */
        d => d.disabled));
        return allAreDisabled;
    }
    /**
     * @param {?} options
     * @param {?} groupByProperty
     * @return {?}
     */
    optionsGrouping(options, groupByProperty) {
        /** @type {?} */
        const getAllUniqueGroupByPropertyValue = this.findUnique(options.map((/**
         * @param {?} item
         * @return {?}
         */
        item => item[groupByProperty])));
        /** @type {?} */
        const result = getAllUniqueGroupByPropertyValue.map((/**
         * @param {?} group
         * @return {?}
         */
        group => {
            /** @type {?} */
            const groupedValues = options.filter((/**
             * @param {?} o
             * @return {?}
             */
            o => o[groupByProperty] === group));
            return {
                name: group,
                values: groupedValues,
                ticked: groupedValues.every((/**
                 * @param {?} o
                 * @return {?}
                 */
                o => o.ticked)),
                disabled: groupedValues.every((/**
                 * @param {?} o
                 * @return {?}
                 */
                o => o.disabled))
            };
        }));
        return result;
    }
    /**
     * @param {?} expression
     * @return {?}
     */
    findUnique(expression) {
        return [...Array.from(new Set(expression))];
    }
    /**
     * @param {?} options
     * @param {?} groupByProperty
     * @return {?}
     */
    virtualOptionsGroupingFlatten(options, groupByProperty) {
        /** @type {?} */
        const allParentGroupedValues = this.findUnique(options.filter((/**
         * @param {?} o
         * @return {?}
         */
        o => !o.parent)).map((/**
         * @param {?} item
         * @return {?}
         */
        item => item[groupByProperty])));
        /** @type {?} */
        const subGroupedValues = this.findUnique(options.filter((/**
         * @param {?} o
         * @return {?}
         */
        o => o.parent)).map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ name, parent }) => ({ name, parent }))));
        /** @type {?} */
        let result = [];
        allParentGroupedValues.forEach((/**
         * @param {?} group
         * @return {?}
         */
        group => {
            result.push({
                name: group,
                isGroup: true,
                ticked: this.allDescendantsAreTicked(options, groupByProperty, group),
                disabled: this.allDescendantsAreDisabled(options, groupByProperty, group)
            });
            /** @type {?} */
            const groupedValues = options
                .filter((/**
             * @param {?} o
             * @return {?}
             */
            o => o[groupByProperty] === group && !o.parent))
                .map((/**
             * @param {?} v
             * @return {?}
             */
            v => (Object.assign(Object.assign({}, v), { depth: 1 }))));
            result = [...result].concat(groupedValues);
            /** @type {?} */
            const childGroupedValues = subGroupedValues.filter((/**
             * @param {?} s
             * @return {?}
             */
            (s) => s.parent === group));
            childGroupedValues.forEach((/**
             * @param {?} c
             * @return {?}
             */
            c => {
                result.push({ name: c, parent: group, isGroup: true });
                /** @type {?} */
                const values = options.filter((/**
                 * @param {?} o
                 * @return {?}
                 */
                o => o[groupByProperty] === c)).map((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => (Object.assign(Object.assign({}, v), { depth: 2 }))));
                result.concat(values);
            }));
        }));
        return result;
    }
    /**
     * @param {?} json
     * @return {?}
     */
    mirrorObject(json) {
        /** @type {?} */
        const ret = {};
        for (var key in json) {
            ret[json[key]] = key;
        }
        return ret;
    }
    /**
     * @param {?} collection
     * @param {?} propertyMap
     * @param {?=} groupedProperty
     * @return {?}
     */
    mapDatasourceToFields(collection, propertyMap, groupedProperty) {
        /** @type {?} */
        let keys = Object.keys(propertyMap);
        return collection.map((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            /** @type {?} */
            let obj = groupedProperty ? { [groupedProperty]: item[groupedProperty] } : {};
            keys.reduce((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => {
                obj[b] = item[propertyMap[b]];
            }), obj);
            return obj;
        }));
    }
}
NgxMultiselectService.ɵfac = function NgxMultiselectService_Factory(t) { return new (t || NgxMultiselectService)(); };
/** @nocollapse */
NgxMultiselectService.ctorParameters = () => [];
/** @nocollapse */ NgxMultiselectService.ɵprov = ɵɵdefineInjectable({ factory: function NgxMultiselectService_Factory() { return new NgxMultiselectService(); }, token: NgxMultiselectService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMultiselectService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/filter-options/filter-options.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FilterOptionsComponent {
    constructor() {
        this.onSearchChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    clearInputFilter() {
        this.filterName.setValue('');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.filterName = new FormControl('');
        this.filterNameSubscription = this.filterName.valueChanges.subscribe((/**
         * @param {?} val
         * @return {?}
         */
        val => this.onSearchChange.emit(val)));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.filterNameSubscription.unsubscribe();
    }
}
FilterOptionsComponent.ɵfac = function FilterOptionsComponent_Factory(t) { return new (t || FilterOptionsComponent)(); };
FilterOptionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FilterOptionsComponent, selectors: [["ms-filter-options"]], outputs: { onSearchChange: "onSearchChange" }, decls: 6, vars: 2, consts: [[1, "input-search"], [1, "field-infix"], ["autofocus", "", "placeholder", "Search options here..", "type", "text", "ngDefaultControl", "", 1, "input-filter", 3, "formControl"], [1, "field-suffix"], ["type", "button", 1, "clear-button", 3, "disabled", "click"]], template: function FilterOptionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "input", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "button", 4);
        ɵngcc0.ɵɵlistener("click", function FilterOptionsComponent_Template_button_click_4_listener() { return ctx.clearInputFilter(); });
        ɵngcc0.ɵɵtext(5, "X");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("formControl", ctx.filterName);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("disabled", !ctx.filterName.value);
    } }, directives: [ɵngcc1.DefaultValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.FormControlDirective], styles: [".input-search[_ngcontent-%COMP%]{align-items:stretch;display:flex;flex-grow:1;height:30px;padding:2px}.mat-multiselect   [_nghost-%COMP%]     .input-search{border-bottom:1px solid rgba(0,0,0,.12)}.mat-multiselect   [_nghost-%COMP%]     .input-filter{border:none;flex-grow:1;font:inherit;outline:none}.mat-multiselect   [_nghost-%COMP%]     .field-infix{display:flex;flex:1;padding:5px}.mat-multiselect   [_nghost-%COMP%]     .field-suffix{margin:3px;white-space:nowrap}.mat-multiselect   [_nghost-%COMP%]     .field-suffix button{border:none;border-radius:10px;font-size:inherit;height:20px;min-width:20px;padding:0;width:20px}.bs-multiselect   [_nghost-%COMP%]     .clear-button{background-color:#f1f1f1;border:none;border-radius:2px;color:#666;cursor:pointer;font-size:inherit;max-width:20px;min-width:20px;padding:0}.bs-multiselect   [_nghost-%COMP%]     .input-filter{border:1px solid #ccc;border-radius:2px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-sizing:border-box;color:#666;cursor:pointer;font-size:inherit;height:30px;height:100%;padding-left:7px;width:100%}.bs-multiselect   [_nghost-%COMP%]     .field-infix{display:flex;flex-grow:1}.bs-multiselect   [_nghost-%COMP%]     .field-suffix{display:flex}"], changeDetection: 0 });
/** @nocollapse */
FilterOptionsComponent.ctorParameters = () => [];
FilterOptionsComponent.propDecorators = {
    onSearchChange: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterOptionsComponent, [{
        type: Component,
        args: [{
                selector: 'ms-filter-options',
                template: "<div class=\"input-search\">\n  <div class=\"field-infix\">\n    <input\n      autofocus\n      placeholder=\"Search options here..\"\n      type=\"text\"\n      [formControl]=\"filterName\"\n      ngDefaultControl\n      class=\"input-filter\"\n    />\n  </div>\n  <div class=\"field-suffix\">\n    <button type=\"button\" [disabled]=\"!filterName.value\" (click)=\"clearInputFilter()\" class=\"clear-button\">X</button>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".input-search{align-items:stretch;display:flex;flex-grow:1;height:30px;padding:2px}.mat-multiselect :host ::ng-deep .input-search{border-bottom:1px solid rgba(0,0,0,.12)}.mat-multiselect :host ::ng-deep .input-filter{border:none;flex-grow:1;font:inherit;outline:none}.mat-multiselect :host ::ng-deep .field-infix{display:flex;flex:1;padding:5px}.mat-multiselect :host ::ng-deep .field-suffix{margin:3px;white-space:nowrap}.mat-multiselect :host ::ng-deep .field-suffix button{border:none;border-radius:10px;font-size:inherit;height:20px;min-width:20px;padding:0;width:20px}.bs-multiselect :host ::ng-deep .clear-button{background-color:#f1f1f1;border:none;border-radius:2px;color:#666;cursor:pointer;font-size:inherit;max-width:20px;min-width:20px;padding:0}.bs-multiselect :host ::ng-deep .input-filter{border:1px solid #ccc;border-radius:2px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-sizing:border-box;color:#666;cursor:pointer;font-size:inherit;height:30px;height:100%;padding-left:7px;width:100%}.bs-multiselect :host ::ng-deep .field-infix{display:flex;flex-grow:1}.bs-multiselect :host ::ng-deep .field-suffix{display:flex}"]
            }]
    }], function () { return []; }, { onSearchChange: [{
            type: Output
        }] }); })();
if (false) {
    /** @type {?} */
    FilterOptionsComponent.prototype.filterName;
    /** @type {?} */
    FilterOptionsComponent.prototype.filterNameSubscription;
    /** @type {?} */
    FilterOptionsComponent.prototype.onSearchChange;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/multiselect.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NgxMultiselectComponent)),
    multi: true
};
class NgxMultiselectComponent {
    /**
     * @param {?} elementRef
     * @param {?} multiselectService
     */
    constructor(elementRef, multiselectService) {
        this.elementRef = elementRef;
        this.multiselectService = multiselectService;
        this._theme = 'material';
        this._isOpen = false;
        this.operationPendingQueue = [];
        // public variables
        this._selectedOptions = null;
        this._defaultPropertyMap = {
            id: 'id',
            name: 'name',
            disabled: 'disabled'
        };
        this._defaultPropertyMapLength = Object.keys(this._defaultPropertyMap).length;
        this.matMultiselect = true;
        this.bsMultiselect = false;
        // Input bindings
        this.disabled = false;
        this.color = 'blue';
        this.showHelperElements = true;
        this.showSearchFilter = true;
        this.showMaxLabels = 3;
        // Output bindings
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this.onItemClick = new EventEmitter();
        this.onGroupItemClick = new EventEmitter();
        this.onSelectAll = new EventEmitter();
        this.onSelectNone = new EventEmitter();
        this.onReset = new EventEmitter();
        this.onClear = new EventEmitter();
        this.onSearchChange = new EventEmitter();
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this.onTouched = (/**
         * @return {?}
         */
        () => { });
        this.filterOptionsList = (/**
         * @param {?} val
         * @return {?}
         */
        (val) => {
            /** @type {?} */
            const optionsCopy = this.getOptionsCopy();
            /** @type {?} */
            let result = optionsCopy;
            if (val) {
                result = optionsCopy.filter((/**
                 * @param {?} i
                 * @return {?}
                 */
                i => i.name && i.name.toLowerCase().indexOf(val.toLowerCase()) !== -1));
            }
            this.setOptions(result);
            this.prepopulateOptions(this._selectedOptions);
        });
    }
    /**
     * @return {?}
     */
    get optionsTemplate() {
        return this._optionsTemplate;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    set optionsTemplate(template) {
        this._optionsTemplate = template;
    }
    /**
     * @return {?}
     */
    get theme() {
        return this._theme;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set theme(val) {
        this._theme = val;
        this.matMultiselect = val === 'material';
        this.bsMultiselect = val === 'bootstrap';
    }
    // Input binding with getter / setter
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        this._isOpen = value;
        // onOpen and onClose event will be fired by isOpen setter
        if (value) {
            // list populate, based on empty value
            this.filterOptionsList('');
            this.onTouched();
            this.onOpen.emit();
        }
        else {
            this.onClose.emit();
        }
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set propertyMap(val) {
        this._defaultPropertyMap = Object.assign(Object.assign({}, this._defaultPropertyMap), val);
    }
    /**
     * @return {?}
     */
    get multiple() {
        return this._multiple;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set multiple(value) {
        this.viewToModel(value ? [] : null);
        this._multiple = value;
    }
    /**
     * @param {?} collection
     * @return {?}
     */
    set options(collection) {
        if (!collection)
            return;
        this._optionsCopy = this.multiselectService.mapDatasourceToFields(collection, this._defaultPropertyMap, this.groupedProperty);
        /** @type {?} */
        const options = this.getOptionsCopy();
        this.setOptions(options);
        // Sometimes binding can happens lazily, 
        // so `finishPendingOperations` helps to execute such operations
        if (this.isOperationPending())
            this.finishPendingOperations();
    }
    // Adding pending operation in queue
    /**
     * @param {?} item
     * @return {?}
     */
    addOperation(item) {
        this.operationPendingQueue.push(item);
    }
    // Poping pending operation from queue sequentially
    /**
     * @return {?}
     */
    popOperation() {
        return this.operationPendingQueue.pop();
    }
    /*
        In future this code is going to resides inside different Service,
        This pendingOperation feature is fine grained in future,
        and can be used for multiple purpose like model update, collection update, etc.
      */
    // Extracting and finishing all pending operation
    /**
     * @return {?}
     */
    finishPendingOperations() {
        /** @type {?} */
        const operation = this.popOperation();
        this.prepopulateOptions(operation);
    }
    // Check pending operation queue status
    /**
     * @return {?}
     */
    isOperationPending() {
        return this.operationPendingQueue.length;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set initialValue(value) {
        this._initialValue = value;
    }
    /**
     * @return {?}
     */
    get initialValue() {
        return this._initialValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        // Set selected value for initial load of value
        if (value) {
            this.initialValue = value;
            this._options ? this.prepopulateOptions(value) : this.addOperation(value);
            this.formatPrepopulatedValues(value);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    formatPrepopulatedValues(value) {
        /** @type {?} */
        let options = value;
        // TODO: can we improve below logic?
        if (Object.keys(this._defaultPropertyMap).length == this._defaultPropertyMapLength)
            return;
        /** @type {?} */
        const swappedPropertyMap = this.multiselectService.mirrorObject(this._defaultPropertyMap);
        if (this.multiple) {
            options.forEach((/**
             * @param {?} o
             * @return {?}
             */
            o => {
                o.id = o[swappedPropertyMap.id];
                o.name = o[swappedPropertyMap.name];
            }));
        }
        else {
            value.id = value[swappedPropertyMap.id];
            value.name = value[swappedPropertyMap.name];
            options = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    // All update to options should happen from below method.
    /**
     * @param {?} options
     * @return {?}
     */
    setOptions(options) {
        this._options = options;
    }
    /**
     * @return {?}
     */
    getOptions() {
        return this._options ? [...this._options] : [];
    }
    /**
     * @return {?}
     */
    getOptionsCopy() {
        return this._optionsCopy ? [...this._optionsCopy] : [];
    }
    /**
     * @return {?}
     */
    isValueSelected() {
        return this._selectedOptions && this._multiple ?
            this._selectedOptions.length :
            this._selectedOptions;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    searchChange(val) {
        this.filterOptionsList(val);
        this.onSearchChange.emit(val);
    }
    /**
     * @return {?}
     */
    close() {
        this.isOpen = false;
    }
    /**
     * @param {?} collection
     * @param {?} item
     * @return {?}
     */
    removeItem(collection, item) {
        item.ticked = false;
        /** @type {?} */
        const index = collection.findIndex((/**
         * @param {?} o
         * @return {?}
         */
        o => o.id === item.id));
        collection.splice(index, 1);
    }
    /**
     * @return {?}
     */
    toggleDropdown() {
        this.isOpen = !this.isOpen;
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    prepopulateOptions(selected) {
        /** @type {?} */
        let selectedIds = [];
        selectedIds = this._multiple ?
            (selected || []).map((/**
             * @param {?} i
             * @return {?}
             */
            i => i.id)) :
            selected ? [selected.id] : [];
        this.setOptions(this.getOptions()
            .map((/**
         * @param {?} o
         * @return {?}
         */
        o => (Object.assign(Object.assign({}, o), { ticked: selectedIds.indexOf(o.id) !== -1 })))));
        // TODO: do we really need this reassignment?
        this.viewToModel(selected);
    }
    /**
     * @param {?} option
     * @return {?}
     */
    select(option) {
        /** @type {?} */
        let selectedOptions;
        option.ticked = !option.ticked;
        // TODO: Refactor below logic
        if (this._multiple) {
            selectedOptions = [...this._selectedOptions];
            /** @type {?} */
            let selectedIds = selectedOptions.map((/**
             * @param {?} i
             * @return {?}
             */
            i => i.id));
            if (selectedIds.indexOf(option.id) === -1) {
                // if selected item not exist in collection, push it
                selectedOptions.push(option);
            }
            else {
                // if selected item exist in collection, post it
                this.removeItem(selectedOptions, option);
            }
            selectedIds = selectedOptions.map((/**
             * @param {?} i
             * @return {?}
             */
            i => i.id));
        }
        else {
            // TODO: find optimized way to do below
            /** @type {?} */
            let val = option && option.id;
            /** @type {?} */
            let changedOptions = this.getOptions()
                .map((/**
             * @param {?} o
             * @return {?}
             */
            o => (Object.assign(Object.assign({}, o), { ticked: o.id == val }))));
            selectedOptions = changedOptions.find((/**
             * @param {?} i
             * @return {?}
             */
            i => i.ticked));
            this.setOptions(changedOptions);
            this.close();
        }
        this.viewToModel(selectedOptions);
        this.onItemClick.emit(option);
    }
    /**
     * @return {?}
     */
    selectAll() {
        /** @type {?} */
        let allSelectedOptions = this.getOptions()
            .map((/**
         * @param {?} o
         * @return {?}
         */
        o => (Object.assign(Object.assign({}, o), { ticked: true }))));
        this.setOptions(allSelectedOptions);
        this.viewToModel(allSelectedOptions);
        this.onSelectAll.emit();
    }
    /**
     * @return {?}
     */
    selectNone() {
        /** @type {?} */
        const options = this.getOptions().map((/**
         * @param {?} o
         * @return {?}
         */
        o => (Object.assign(Object.assign({}, o), { ticked: false }))));
        this.setOptions(options);
        this.viewToModel([]);
        this.onSelectNone.emit();
    }
    /**
     * @return {?}
     */
    borderBottom() {
        return this._isOpen ? { borderBottom: `1px solid ${this.matMultiselect ? this.color : 'transperant'}` } : {};
    }
    //TODO: Optimized below logic, it can be done in lesser steps
    /**
     * @param {?} group
     * @return {?}
     */
    selectGroup(group) {
        const { ticked, values } = group;
        /** @type {?} */
        const options = this.getOptions();
        /** @type {?} */
        let selectedValues = [...this._selectedOptions];
        /** @type {?} */
        let selectedIds = selectedValues.map((/**
         * @param {?} s
         * @return {?}
         */
        s => s.id));
        /** @type {?} */
        const allGroupOptionIds = values.map((/**
         * @param {?} v
         * @return {?}
         */
        v => v.id));
        // Get all ticked options
        // concat with selected options
        selectedValues = ticked
            ? selectedValues.concat(values)
            : selectedValues.filter((/**
             * @param {?} o
             * @return {?}
             */
            o => allGroupOptionIds.indexOf(o.id) === -1));
        // Find unique out of them
        selectedIds = this.multiselectService.findUnique(selectedValues.map((/**
         * @param {?} item
         * @return {?}
         */
        item => item.id)));
        // build selectedOptions array again
        selectedValues = options.filter((/**
         * @param {?} o
         * @return {?}
         */
        o => selectedIds.indexOf(o.id) !== -1));
        this.viewToModel(selectedValues);
        this.onGroupItemClick.emit(group);
    }
    /**
     * @return {?}
     */
    reset() {
        this.viewToModel(this.initialValue);
        this.prepopulateOptions(this.initialValue);
        this.onReset.emit();
    }
    // Responsible for updating value from view to model
    /**
     * @param {?} selected
     * @return {?}
     */
    viewToModel(selected) {
        if (this._selectedOptions !== selected) {
            this._selectedOptions = selected;
            this.onChange(selected);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clear(event) {
        /** @type {?} */
        let changedOptions = this.getOptions().map((/**
         * @param {?} o
         * @return {?}
         */
        o => (Object.assign(Object.assign({}, o), { ticked: false }))));
        this.setOptions(changedOptions);
        // no value is selected so passing null
        this.viewToModel(null);
        this.onClear.emit();
        this.close();
        event.stopPropagation();
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Check if value have not been assigned then default to true
        if (typeof this._multiple === 'undefined') {
            this.multiple = true;
        }
    }
    // TODO: Consider creating a directive for this.
    // TODO: Also convert below to be work for element specific
    /**
     * @param {?} event
     * @return {?}
     */
    clickOutSide(event) {
        if (this.isOpen &&
            this.elementRef.nativeElement !== event &&
            !this.multiselectService.closest(event, 'ngx-multiselect')) {
            this.close();
        }
    }
}
NgxMultiselectComponent.ɵfac = function NgxMultiselectComponent_Factory(t) { return new (t || NgxMultiselectComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgxMultiselectService)); };
NgxMultiselectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMultiselectComponent, selectors: [["ngx-multiselect"]], contentQueries: function NgxMultiselectComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TemplateRef, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._optionsTemplate = _t.first);
    } }, viewQuery: function NgxMultiselectComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true, FilterOptionsComponent);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterOptions = _t.first);
    } }, hostVars: 4, hostBindings: function NgxMultiselectComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NgxMultiselectComponent_click_HostBindingHandler($event) { return ctx.clickOutSide($event.target); }, false, ɵngcc0.ɵɵresolveDocument);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-multiselect", ctx.matMultiselect)("bs-multiselect", ctx.bsMultiselect);
    } }, inputs: { disabled: "disabled", color: "color", showHelperElements: "showHelperElements", showSearchFilter: "showSearchFilter", showMaxLabels: "showMaxLabels", optionsTemplate: "optionsTemplate", theme: "theme", isOpen: "isOpen", propertyMap: "propertyMap", multiple: "multiple", options: "options", groupedProperty: "groupedProperty" }, outputs: { onOpen: "onOpen", onClose: "onClose", onItemClick: "onItemClick", onGroupItemClick: "onGroupItemClick", onSelectAll: "onSelectAll", onSelectNone: "onSelectNone", onReset: "onReset", onClear: "onClear", onSearchChange: "onSearchChange" }, features: [ɵngcc0.ɵɵProvidersFeature([DEFAULT_VALUE_ACCESSOR])], decls: 11, vars: 8, consts: [[1, "multiselect-wrapper"], [1, "dropdown-button", 3, "ngClass", "click"], [1, "selection", 3, "ngStyle"], ["class", "none-selected", 4, "ngIf"], ["class", "selected", 4, "ngIf"], [1, "symbols"], ["class", "close", 3, "click", 4, "ngIf"], [1, "caret"], ["class", "listing-wrapper", 4, "ngIf"], ["groupedTemplate", ""], [1, "none-selected"], [1, "selected"], [1, "text"], [1, "close", 3, "click"], [1, "listing-wrapper"], [3, "multiple", "disabled", "onClear", "resetClicked", "onSearchChange", "selectNoneClicked", "selectAllClicked", 4, "ngIf"], [3, "onSearchChange", 4, "ngIf"], [4, "ngIf", "ngIfElse"], [3, "multiple", "disabled", "onClear", "resetClicked", "onSearchChange", "selectNoneClicked", "selectAllClicked"], [3, "onSearchChange"], ["filterOptions", ""], [3, "optionsTemplate", "options", "disabled", "selectOption"], [3, "multiple", "optionsTemplate", "selectedOptions", "options", "disabled", "groupedProperty", "selectOption", "selectGroup"]], template: function NgxMultiselectComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function NgxMultiselectComponent_Template_button_click_1_listener() { return ctx.toggleDropdown(); });
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, NgxMultiselectComponent_span_3_Template, 2, 0, "span", 3);
        ɵngcc0.ɵɵtemplate(4, NgxMultiselectComponent_span_4_Template, 4, 4, "span", 4);
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵtemplate(6, NgxMultiselectComponent_span_6_Template, 2, 0, "span", 6);
        ɵngcc0.ɵɵelement(7, "span", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, NgxMultiselectComponent_div_8_Template, 4, 4, "div", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, NgxMultiselectComponent_ng_template_9_Template, 1, 6, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(6, _c1, ctx.isOpen));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.borderBottom());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isValueSelected());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isValueSelected());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isValueSelected() && !ctx.multiple);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isOpen);
    } }, directives: function () { return [ɵngcc2.NgClass, ɵngcc2.NgStyle, ɵngcc2.NgIf, HelperElementsComponent, FilterOptionsComponent, OptionsComponent, GroupedOptionsComponent]; }, pipes: function () { return [DisplaySelectedValuePipe]; }, styles: ["[_nghost-%COMP%]{display:inline-block;outline:none}.multiselect-wrapper[_ngcontent-%COMP%]{display:flex;flex-grow:1;width:240px}.selection[_ngcontent-%COMP%]{flex-grow:1;justify-content:space-between}.selection[_ngcontent-%COMP%], .symbols[_ngcontent-%COMP%]{align-items:center;display:flex}.symbols[_ngcontent-%COMP%]{justify-content:flex-end}.symbols[_ngcontent-%COMP%]   .caret[_ngcontent-%COMP%]{border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid}.dropdown-button[_ngcontent-%COMP%]{-moz-user-select:none;-ms-user-select:none;-o-user-select:none;-webkit-user-select:none;background-color:#fff;border:none;cursor:pointer;display:flex;flex-grow:1;font-size:inherit;min-height:39px;padding:5px;user-select:none;white-space:normal}.listing-wrapper[_ngcontent-%COMP%]{background-color:#fff;border:1px solid rgba(0,0,0,.15);border-radius:4px;box-shadow:0 6px 12px rgba(0,0,0,.175);position:absolute;width:inherit;z-index:999}  .options-container{height:200px;overflow-y:scroll}.mat-multiselect[_nghost-%COMP%]     .option{-webkit-tap-highlight-color:transparent;align-items:center;border-left:.5px solid #eee;display:flex;flex-flow:row;height:40px;max-height:40px;outline:0;overflow:hidden;padding:0 6px;text-overflow:ellipsis;white-space:nowrap}.mat-multiselect[_nghost-%COMP%]     .option.marked, .mat-multiselect[_nghost-%COMP%]     .option.marked:hover, .mat-multiselect[_nghost-%COMP%]     .option:hover:not(.message){background-image:linear-gradient(#e9e9e9,#f1f1f1);color:#555;cursor:pointer;justify-content:space-between}.mat-multiselect[_nghost-%COMP%]     .marked:after{content:\"\u2713\"}.mat-multiselect[_nghost-%COMP%]     .option.disabled, .mat-multiselect[_nghost-%COMP%]     .option.disabled:hover:not(.message), .mat-multiselect[_nghost-%COMP%]     .option.disabled label input:hover~span{color:#c4c4c4!important;cursor:not-allowed!important;pointer-events:none}.mat-multiselect[_nghost-%COMP%]     .none-selected{-webkit-text-fill-color:#7a7a7a;color:#7a7a7a;transition:none}.mat-multiselect[_nghost-%COMP%]     .dropdown-button{color:#000}.mat-multiselect[_nghost-%COMP%]     .selection{border-bottom:1px solid #000;color:#000;padding-bottom:10px}.mat-multiselect[_nghost-%COMP%]     .open .selection{border-bottom:1px solid #00f}.bs-multiselect[_nghost-%COMP%]     .marked{background-color:green}.bs-multiselect[_nghost-%COMP%]     .dropdown-button{background-image:linear-gradient(#fff,#f7f7f7);border:1px solid #c6c6c6;border-radius:4px;color:#555}.bs-multiselect[_nghost-%COMP%]     .option{align-items:center;background-color:transparent;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);color:#555;display:flex;font-size:inherit;height:40px;max-height:40px;padding:0 6px}.bs-multiselect[_nghost-%COMP%]     .option:hover{background-image:linear-gradient(#c1c1c1,#999)!important;color:#fff!important;cursor:pointer}.bs-multiselect[_nghost-%COMP%]     .option.marked{background-image:linear-gradient(#e9e9e9,#f1f1f1);color:#555;cursor:pointer;display:flex;justify-content:space-between}.bs-multiselect[_nghost-%COMP%]     .marked:after{content:\"\u2713\";width:15px}.bs-multiselect[_nghost-%COMP%]     .option.disabled, .bs-multiselect[_nghost-%COMP%]     .option.disabled:hover, .bs-multiselect[_nghost-%COMP%]     .option.disabled label input:hover~span{color:#c4c4c4!important;cursor:not-allowed!important;pointer-events:none}"], changeDetection: 0 });
/** @nocollapse */
NgxMultiselectComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgxMultiselectService }
];
NgxMultiselectComponent.propDecorators = {
    matMultiselect: [{ type: HostBinding, args: ['class.mat-multiselect',] }],
    bsMultiselect: [{ type: HostBinding, args: ['class.bs-multiselect',] }],
    disabled: [{ type: Input }],
    color: [{ type: Input }],
    groupedProperty: [{ type: Input }],
    showHelperElements: [{ type: Input }],
    showSearchFilter: [{ type: Input }],
    showMaxLabels: [{ type: Input }],
    _optionsTemplate: [{ type: ContentChild, args: [TemplateRef,] }],
    optionsTemplate: [{ type: Input }],
    theme: [{ type: Input }],
    isOpen: [{ type: Input }],
    propertyMap: [{ type: Input }],
    multiple: [{ type: Input }],
    options: [{ type: Input }],
    onOpen: [{ type: Output }],
    onClose: [{ type: Output }],
    onItemClick: [{ type: Output }],
    onGroupItemClick: [{ type: Output }],
    onSelectAll: [{ type: Output }],
    onSelectNone: [{ type: Output }],
    onReset: [{ type: Output }],
    onClear: [{ type: Output }],
    onSearchChange: [{ type: Output }],
    filterOptions: [{ type: ViewChild, args: ['filterOptions', { read: FilterOptionsComponent },] }],
    clickOutSide: [{ type: HostListener, args: ['document:click', ['$event.target'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMultiselectComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-multiselect',
                template: "<div class=\"multiselect-wrapper\">\n  <button class=\"dropdown-button\" (click)=\"toggleDropdown()\" [ngClass]=\"{ open: isOpen }\">\n    <div class=\"selection\" [ngStyle]=\"borderBottom()\">\n      <!-- TODO: None selected template should be ng-template -->\n      <span class=\"none-selected\" *ngIf=\"!isValueSelected()\">None selected</span>\n      <span class=\"selected\" *ngIf=\"isValueSelected()\">\n        <span class=\"text\">{{_selectedOptions | displaySelectedValue: showMaxLabels}}</span>\n      </span>\n      <div class=\"symbols\">\n        <span class=\"close\" (click)=\"clear($event)\" *ngIf=\"isValueSelected() && !multiple\">\u00D7</span>\n        <span class=\"caret\"></span>\n      </div>\n    </div>\n  </button>\n  <div class=\"listing-wrapper\" *ngIf=\"isOpen\">\n    <ms-helper-elements\n      *ngIf=\"showHelperElements\"\n      [multiple]=\"multiple\"\n      [disabled]=\"disabled\"\n      (onClear)=\"onClear.emit()\"\n      (resetClicked)=\"reset()\"\n      (onSearchChange)=\"onSearchChange.emit($event)\"\n      (selectNoneClicked)=\"selectNone()\"\n      (selectAllClicked)=\"selectAll()\"\n      (selectNoneClicked)=\"selectNone()\"\n    >\n    </ms-helper-elements>\n    <ms-filter-options\n      *ngIf=\"showSearchFilter\"\n      #filterOptions\n      (onSearchChange)=\"searchChange($event)\"\n    ></ms-filter-options>\n    <ng-container *ngIf=\"!groupedProperty; else groupedTemplate\">\n      <ms-options\n        [optionsTemplate]=\"optionsTemplate\"\n        [options]=\"_options\"\n        [disabled]=\"disabled\"\n        (selectOption)=\"select($event)\"\n      ></ms-options>\n    </ng-container>\n  </div>\n</div>\n<ng-template #groupedTemplate>\n  <ms-grouped-options\n    [multiple]=\"multiple\"\n    [optionsTemplate]=\"optionsTemplate\"\n    [selectedOptions]=\"_selectedOptions\"\n    [options]=\"_options\"\n    [disabled]=\"disabled\"\n    [groupedProperty]=\"groupedProperty\"\n    (selectOption)=\"select($event)\"\n    (selectGroup)=\"selectGroup($event)\"\n  >\n  </ms-grouped-options>\n</ng-template>\n",
                providers: [DEFAULT_VALUE_ACCESSOR],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:inline-block;outline:none}.multiselect-wrapper{display:flex;flex-grow:1;width:240px}.selection{flex-grow:1;justify-content:space-between}.selection,.symbols{align-items:center;display:flex}.symbols{justify-content:flex-end}.symbols .caret{border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid}.dropdown-button{-moz-user-select:none;-ms-user-select:none;-o-user-select:none;-webkit-user-select:none;background-color:#fff;border:none;cursor:pointer;display:flex;flex-grow:1;font-size:inherit;min-height:39px;padding:5px;user-select:none;white-space:normal}.listing-wrapper{background-color:#fff;border:1px solid rgba(0,0,0,.15);border-radius:4px;box-shadow:0 6px 12px rgba(0,0,0,.175);position:absolute;width:inherit;z-index:999}::ng-deep .options-container{height:200px;overflow-y:scroll}:host.mat-multiselect ::ng-deep .option{-webkit-tap-highlight-color:transparent;align-items:center;border-left:.5px solid #eee;display:flex;flex-flow:row;height:40px;max-height:40px;outline:0;overflow:hidden;padding:0 6px;text-overflow:ellipsis;white-space:nowrap}:host.mat-multiselect ::ng-deep .option.marked,:host.mat-multiselect ::ng-deep .option.marked:hover,:host.mat-multiselect ::ng-deep .option:hover:not(.message){background-image:linear-gradient(#e9e9e9,#f1f1f1);color:#555;cursor:pointer;justify-content:space-between}:host.mat-multiselect ::ng-deep .marked:after{content:\"\u2713\"}:host.mat-multiselect ::ng-deep .option.disabled,:host.mat-multiselect ::ng-deep .option.disabled:hover:not(.message),:host.mat-multiselect ::ng-deep .option.disabled label input:hover~span{color:#c4c4c4!important;cursor:not-allowed!important;pointer-events:none}:host.mat-multiselect ::ng-deep .none-selected{-webkit-text-fill-color:#7a7a7a;color:#7a7a7a;transition:none}:host.mat-multiselect ::ng-deep .dropdown-button{color:#000}:host.mat-multiselect ::ng-deep .selection{border-bottom:1px solid #000;color:#000;padding-bottom:10px}:host.mat-multiselect ::ng-deep .open .selection{border-bottom:1px solid #00f}:host.bs-multiselect ::ng-deep .marked{background-color:green}:host.bs-multiselect ::ng-deep .dropdown-button{background-image:linear-gradient(#fff,#f7f7f7);border:1px solid #c6c6c6;border-radius:4px;color:#555}:host.bs-multiselect ::ng-deep .option{align-items:center;background-color:transparent;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);color:#555;display:flex;font-size:inherit;height:40px;max-height:40px;padding:0 6px}:host.bs-multiselect ::ng-deep .option:hover{background-image:linear-gradient(#c1c1c1,#999)!important;color:#fff!important;cursor:pointer}:host.bs-multiselect ::ng-deep .option.marked{background-image:linear-gradient(#e9e9e9,#f1f1f1);color:#555;cursor:pointer;display:flex;justify-content:space-between}:host.bs-multiselect ::ng-deep .marked:after{content:\"\u2713\";width:15px}:host.bs-multiselect ::ng-deep .option.disabled,:host.bs-multiselect ::ng-deep .option.disabled:hover,:host.bs-multiselect ::ng-deep .option.disabled label input:hover~span{color:#c4c4c4!important;cursor:not-allowed!important;pointer-events:none}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NgxMultiselectService }]; }, { matMultiselect: [{
            type: HostBinding,
            args: ['class.mat-multiselect']
        }], bsMultiselect: [{
            type: HostBinding,
            args: ['class.bs-multiselect']
        }], disabled: [{
            type: Input
        }], color: [{
            type: Input
        }], showHelperElements: [{
            type: Input
        }], showSearchFilter: [{
            type: Input
        }], showMaxLabels: [{
            type: Input
        }], onOpen: [{
            type: Output
        }], onClose: [{
            type: Output
        }], onItemClick: [{
            type: Output
        }], onGroupItemClick: [{
            type: Output
        }], onSelectAll: [{
            type: Output
        }], onSelectNone: [{
            type: Output
        }], onReset: [{
            type: Output
        }], onClear: [{
            type: Output
        }], onSearchChange: [{
            type: Output
        }], optionsTemplate: [{
            type: Input
        }], _optionsTemplate: [{
            type: ContentChild,
            args: [TemplateRef]
        }], theme: [{
            type: Input
        }], isOpen: [{
            type: Input
        }], propertyMap: [{
            type: Input
        }], multiple: [{
            type: Input
        }], options: [{
            type: Input
        }], 
    // TODO: Consider creating a directive for this.
    // TODO: Also convert below to be work for element specific
    /**
     * @param {?} event
     * @return {?}
     */
    clickOutSide: [{
            type: HostListener,
            args: ['document:click', ['$event.target']]
        }], groupedProperty: [{
            type: Input
        }], filterOptions: [{
            type: ViewChild,
            args: ['filterOptions', { read: FilterOptionsComponent }]
        }] }); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._multiple;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._theme;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._optionsCopy;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._isOpen;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype.operationPendingQueue;
    /** @type {?} */
    NgxMultiselectComponent.prototype._selectedOptions;
    /** @type {?} */
    NgxMultiselectComponent.prototype._defaultPropertyMap;
    /** @type {?} */
    NgxMultiselectComponent.prototype._defaultPropertyMapLength;
    /** @type {?} */
    NgxMultiselectComponent.prototype._options;
    /** @type {?} */
    NgxMultiselectComponent.prototype.matMultiselect;
    /** @type {?} */
    NgxMultiselectComponent.prototype.bsMultiselect;
    /** @type {?} */
    NgxMultiselectComponent.prototype.disabled;
    /** @type {?} */
    NgxMultiselectComponent.prototype.color;
    /** @type {?} */
    NgxMultiselectComponent.prototype.groupedProperty;
    /** @type {?} */
    NgxMultiselectComponent.prototype.showHelperElements;
    /** @type {?} */
    NgxMultiselectComponent.prototype.showSearchFilter;
    /** @type {?} */
    NgxMultiselectComponent.prototype.showMaxLabels;
    /** @type {?} */
    NgxMultiselectComponent.prototype._optionsTemplate;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onOpen;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onClose;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onItemClick;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onGroupItemClick;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onSelectAll;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onSelectNone;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onReset;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onClear;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onSearchChange;
    /** @type {?} */
    NgxMultiselectComponent.prototype.filterOptions;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype._initialValue;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onChange;
    /** @type {?} */
    NgxMultiselectComponent.prototype.onTouched;
    /** @type {?} */
    NgxMultiselectComponent.prototype.filterOptionsList;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NgxMultiselectComponent.prototype.multiselectService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/display-selected-value.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DOTS = ' ...';
class DisplaySelectedValuePipe {
    constructor() {
        this.defaultMaxLabelCount = 3;
    }
    /**
     * @param {?} value
     * @param {?=} maxLabelCount
     * @return {?}
     */
    transform(value, maxLabelCount = this.defaultMaxLabelCount) {
        if (value instanceof Array) {
            /** @type {?} */
            const collection = [...value];
            /** @type {?} */
            var total = collection.length;
            /** @type {?} */
            const condn = collection.length > maxLabelCount;
            condn ? (collection.length = maxLabelCount) : null;
            return `${collection.map((/**
             * @param {?} v
             * @return {?}
             */
            v => v.name)).join(', ')}${condn ? DOTS + ' (' + total + ')' : ''}`;
        }
        return value && value.name;
    }
}
DisplaySelectedValuePipe.ɵfac = function DisplaySelectedValuePipe_Factory(t) { return new (t || DisplaySelectedValuePipe)(); };
DisplaySelectedValuePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "displaySelectedValue", type: DisplaySelectedValuePipe, pure: false });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DisplaySelectedValuePipe, [{
        type: Pipe,
        args: [{
                name: 'displaySelectedValue',
                pure: false
            }]
    }], function () { return []; }, null); })();
if (false) {
    /** @type {?} */
    DisplaySelectedValuePipe.prototype.defaultMaxLabelCount;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/helper-elements/helper-elements.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HelperElementsComponent {
    constructor() {
        this.multiple = false;
        this.disabled = false;
        this.selectAllClicked = new EventEmitter();
        this.selectNoneClicked = new EventEmitter();
        this.resetClicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    selectAll() {
        this.selectAllClicked.emit();
    }
    /**
     * @return {?}
     */
    selectNone() {
        this.selectNoneClicked.emit();
    }
    /**
     * @return {?}
     */
    reset() {
        this.resetClicked.emit();
    }
}
HelperElementsComponent.ɵfac = function HelperElementsComponent_Factory(t) { return new (t || HelperElementsComponent)(); };
HelperElementsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HelperElementsComponent, selectors: [["ms-helper-elements"]], inputs: { multiple: "multiple", disabled: "disabled" }, outputs: { selectAllClicked: "selectAllClicked", selectNoneClicked: "selectNoneClicked", resetClicked: "resetClicked" }, decls: 5, vars: 2, consts: [[1, "helper-buttons"], [3, "disabled"], [4, "ngIf"], [1, "helper-button", 3, "click"]], template: function HelperElementsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "fieldset", 1);
        ɵngcc0.ɵɵtemplate(2, HelperElementsComponent_ng_container_2_Template, 5, 0, "ng-container", 2);
        ɵngcc0.ɵɵelementStart(3, "button", 3);
        ɵngcc0.ɵɵlistener("click", function HelperElementsComponent_Template_button_click_3_listener() { return ctx.reset(); });
        ɵngcc0.ɵɵtext(4, "\u21B6 Reset");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.multiple);
    } }, directives: [ɵngcc2.NgIf], styles: [".helper-button[_ngcontent-%COMP%]{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;border:1px solid rgba(0,0,0,.12);border-radius:.25rem;font-size:.75rem;font-weight:400;height:30px;max-height:30px;user-select:none;white-space:nowrap}fieldset[_ngcontent-%COMP%]{border:none;padding:0}.helper-buttons[_ngcontent-%COMP%]{border-bottom:1px solid #ddd;padding:2px}.mat-multiselect   [_nghost-%COMP%]   .helper-button[_ngcontent-%COMP%]{background-color:transparent;color:#444}.mat-multiselect   [_nghost-%COMP%]   .helper-button[_ngcontent-%COMP%]:not(:last-child){margin:0 2px}.bs-multiselect   [_nghost-%COMP%]   .helper-button[_ngcontent-%COMP%]{-webkit-tap-highlight-color:transparent;box-sizing:border-box;cursor:pointer;outline:0;padding:.25em}.bs-multiselect[_ngcontent-%COMP%]   .helper-button[_ngcontent-%COMP%]:not(:last-child){margin-right:4px}"], changeDetection: 0 });
/** @nocollapse */
HelperElementsComponent.ctorParameters = () => [];
HelperElementsComponent.propDecorators = {
    multiple: [{ type: Input }],
    disabled: [{ type: Input }],
    selectAllClicked: [{ type: Output }],
    selectNoneClicked: [{ type: Output }],
    resetClicked: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HelperElementsComponent, [{
        type: Component,
        args: [{
                selector: 'ms-helper-elements',
                template: "<div class=\"helper-buttons\">\n  <fieldset [disabled]=\"disabled\">\n    <ng-container *ngIf=\"multiple\">\n      <button class=\"helper-button\" (click)=\"selectAll()\">\u2713 Select All</button>\n      <button class=\"helper-button\" (click)=\"selectNone()\">\u00D7 Select None</button>\n    </ng-container>\n    <button class=\"helper-button\" (click)=\"reset()\">\u21B6 Reset</button>\n  </fieldset>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".helper-button{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;border:1px solid rgba(0,0,0,.12);border-radius:.25rem;font-size:.75rem;font-weight:400;height:30px;max-height:30px;user-select:none;white-space:nowrap}fieldset{border:none;padding:0}.helper-buttons{border-bottom:1px solid #ddd;padding:2px}.mat-multiselect :host .helper-button{background-color:transparent;color:#444}.mat-multiselect :host .helper-button:not(:last-child){margin:0 2px}.bs-multiselect :host .helper-button{-webkit-tap-highlight-color:transparent;box-sizing:border-box;cursor:pointer;outline:0;padding:.25em}.bs-multiselect .helper-button:not(:last-child){margin-right:4px}"]
            }]
    }], function () { return []; }, { multiple: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selectAllClicked: [{
            type: Output
        }], selectNoneClicked: [{
            type: Output
        }], resetClicked: [{
            type: Output
        }] }); })();
if (false) {
    /** @type {?} */
    HelperElementsComponent.prototype.multiple;
    /** @type {?} */
    HelperElementsComponent.prototype.disabled;
    /** @type {?} */
    HelperElementsComponent.prototype.selectAllClicked;
    /** @type {?} */
    HelperElementsComponent.prototype.selectNoneClicked;
    /** @type {?} */
    HelperElementsComponent.prototype.resetClicked;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/options/options.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OptionsComponent {
    constructor() {
        this._options = [];
        this.disabled = false;
        this.selectOption = new EventEmitter();
        this.start = 0;
        this.end = 5;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set options(value) {
        this._options = value;
    }
    /**
     * @return {?}
     */
    get() {
        return this._options;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    getOptionStyle(option) {
        return { marked: option.ticked, disabled: this.disabled || option.disabled };
    }
    /**
     * @param {?} option
     * @return {?}
     */
    select(option) {
        this.selectOption.emit(option);
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    updateRange({ start, end }) {
        this.filteredOptions = [...this._options].slice(start, end);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const { options } = changes;
        if (!this.optionsTemplate) {
            this.optionsTemplate = this.defaultOptionsTemplate;
        }
        if (options.currentValue !== options.previousValue) {
            this.updateRange({ start: this.start, end: this.end });
        }
    }
}
OptionsComponent.ɵfac = function OptionsComponent_Factory(t) { return new (t || OptionsComponent)(); };
OptionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: OptionsComponent, selectors: [["ms-options"]], viewQuery: function OptionsComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c2, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultOptionsTemplate = _t.first);
    } }, inputs: { disabled: "disabled", options: "options", optionsTemplate: "optionsTemplate" }, outputs: { selectOption: "selectOption" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 10, vars: 3, consts: [["msVirtualScroll", "", 1, "options-container", 3, "totalCount", "rangeChanged"], [1, "top"], ["top", ""], [4, "ngIf", "ngIfElse"], [1, "bottom"], ["bottom", ""], ["defaultOptionsTemplate", ""], ["noOptions", ""], ["class", "option", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], [1, "option", 3, "ngClass", "click"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "option", "message"]], template: function OptionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("rangeChanged", function OptionsComponent_Template_div_rangeChanged_0_listener($event) { return ctx.updateRange($event); });
        ɵngcc0.ɵɵelement(1, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(3, OptionsComponent_ng_container_3_Template, 2, 1, "ng-container", 3);
        ɵngcc0.ɵɵelement(4, "div", 4, 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, OptionsComponent_ng_template_6_Template, 1, 1, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, OptionsComponent_ng_template_8_Template, 2, 0, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r5 = ɵngcc0.ɵɵreference(9);
        ɵngcc0.ɵɵproperty("totalCount", ctx._options == null ? null : ctx._options.length);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteredOptions.length)("ngIfElse", _r5);
    } }, directives: function () { return [VirtualScrollDirective, ɵngcc2.NgIf, ɵngcc2.NgForOf, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet]; }, styles: [""], changeDetection: 0 });
/** @nocollapse */
OptionsComponent.ctorParameters = () => [];
OptionsComponent.propDecorators = {
    disabled: [{ type: Input }],
    options: [{ type: Input }],
    optionsTemplate: [{ type: Input }],
    selectOption: [{ type: Output }],
    defaultOptionsTemplate: [{ type: ViewChild, args: ['defaultOptionsTemplate', { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(OptionsComponent, [{
        type: Component,
        args: [{
                selector: 'ms-options',
                template: "<div class=\"options-container\" msVirtualScroll [totalCount]=\"_options?.length\" (rangeChanged)=\"updateRange($event)\">\n  <div #top class=\"top\"></div>\n  <ng-container *ngIf=\"filteredOptions.length; else noOptions\">\n    <div\n      class=\"option\"\n      [ngClass]=\"getOptionStyle(option)\"\n      *ngFor=\"let option of filteredOptions\"\n      (click)=\"select(option)\"\n    >\n      <ng-container\n        *ngTemplateOutlet=\"\n          optionsTemplate;\n          context: {\n            option: option\n          }\n        \"\n      ></ng-container>\n    </div>\n  </ng-container>\n  <div #bottom class=\"bottom\"></div>\n</div>\n<ng-template #defaultOptionsTemplate let-option=\"option\">\n  {{ option.name }}\n</ng-template>\n<ng-template #noOptions let-option=\"option\">\n  <div class=\"option message\">\n    No options available.\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            }]
    }], function () { return []; }, { disabled: [{
            type: Input
        }], selectOption: [{
            type: Output
        }], options: [{
            type: Input
        }], optionsTemplate: [{
            type: Input
        }], defaultOptionsTemplate: [{
            type: ViewChild,
            args: ['defaultOptionsTemplate', { static: true }]
        }] }); })();
if (false) {
    /** @type {?} */
    OptionsComponent.prototype._options;
    /** @type {?} */
    OptionsComponent.prototype.disabled;
    /** @type {?} */
    OptionsComponent.prototype.optionsTemplate;
    /** @type {?} */
    OptionsComponent.prototype.selectOption;
    /** @type {?} */
    OptionsComponent.prototype.start;
    /** @type {?} */
    OptionsComponent.prototype.end;
    /** @type {?} */
    OptionsComponent.prototype.filteredOptions;
    /** @type {?} */
    OptionsComponent.prototype.defaultOptionsTemplate;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/grouped-options/grouped-options.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GroupedOptionsComponent {
    /**
     * @param {?} multiselectService
     */
    constructor(multiselectService) {
        this.multiselectService = multiselectService;
        this._options = [];
        this._selectedOptions = [];
        this.groupedOptions = [];
        this.start = 0;
        this.end = 5;
        this.disabled = false;
        this.multiple = false;
        this.selectGroup = new EventEmitter();
        this.selectOption = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedOptions(value) {
        this._selectedOptions = value;
        this.formGroupOptions(this._options, this._selectedOptions);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set options(value) {
        this._options = value;
        this.formGroupOptions(value, this._selectedOptions);
    }
    /**
     * @return {?}
     */
    get options() {
        return this.groupedOptions;
    }
    // TODO: Refactor below logic
    /**
     * @param {?} collection
     * @param {?} selectedOptions
     * @return {?}
     */
    formGroupOptions(collection, selectedOptions) {
        /** @type {?} */
        let selectedIds = this.multiple ?
            (selectedOptions || []).map((/**
             * @param {?} s
             * @return {?}
             */
            s => s.id)) :
            selectedOptions ? [selectedOptions.id]
                : [];
        /** @type {?} */
        const values = collection.map((/**
         * @param {?} v
         * @return {?}
         */
        v => (Object.assign(Object.assign({}, v), { ticked: !v.isGroup ? selectedIds.indexOf(v.id) !== -1 : v.ticked }))));
        this.groupedOptions = this.multiselectService.virtualOptionsGroupingFlatten(values, this.groupedProperty);
        this.updateRange({ start: this.start, end: this.end });
    }
    /**
     * @param {?} option
     * @return {?}
     */
    getOptionStyle(option) {
        return {
            group: option.isGroup,
            marked: option.ticked,
            disabled: this.disabled || option.disabled
        };
    }
    /**
     * @param {?} _
     * @param {?} option
     * @return {?}
     */
    trackByFn(_, option) {
        return option.id;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    updateRange({ start, end }) {
        this.start = start;
        this.end = end;
        this.filteredOptions = [...this.options].slice(start, end);
    }
    /**
     * @param {?} option
     * @return {?}
     */
    select(option) {
        if (!option.isGroup) {
            this.selectOption.emit(option);
        }
        else {
            option.ticked = !option.ticked;
            /** @type {?} */
            const values = this.multiselectService.collectAllDescendants(this.options, this.groupedProperty, option.name);
            this.selectGroup.emit(Object.assign(Object.assign({}, option), { values: values }));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (!this.optionsTemplate) {
            this.optionsTemplate = this.defaultOptionsTemplate;
        }
    }
}
GroupedOptionsComponent.ɵfac = function GroupedOptionsComponent_Factory(t) { return new (t || GroupedOptionsComponent)(ɵngcc0.ɵɵdirectiveInject(NgxMultiselectService)); };
GroupedOptionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GroupedOptionsComponent, selectors: [["ms-grouped-options"]], viewQuery: function GroupedOptionsComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c2, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultOptionsTemplate = _t.first);
    } }, inputs: { disabled: "disabled", multiple: "multiple", selectedOptions: "selectedOptions", options: "options", optionsTemplate: "optionsTemplate", groupedProperty: "groupedProperty" }, outputs: { selectGroup: "selectGroup", selectOption: "selectOption" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 10, vars: 3, consts: [["msVirtualScroll", "", 1, "options-container", 3, "totalCount", "rangeChanged"], [1, "top"], ["top", ""], [4, "ngIf", "ngIfElse"], [1, "bottom"], ["bottom", ""], ["defaultOptionsTemplate", ""], ["noOptions", ""], ["class", "option", 3, "ngStyle", "ngClass", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "option", 3, "ngStyle", "ngClass", "click"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "option", "message"]], template: function GroupedOptionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("rangeChanged", function GroupedOptionsComponent_Template_div_rangeChanged_0_listener($event) { return ctx.updateRange($event); });
        ɵngcc0.ɵɵelement(1, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(3, GroupedOptionsComponent_ng_container_3_Template, 2, 2, "ng-container", 3);
        ɵngcc0.ɵɵelement(4, "div", 4, 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, GroupedOptionsComponent_ng_template_6_Template, 1, 1, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, GroupedOptionsComponent_ng_template_8_Template, 2, 0, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r5 = ɵngcc0.ɵɵreference(9);
        ɵngcc0.ɵɵproperty("totalCount", ctx.options.length);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteredOptions.length)("ngIfElse", _r5);
    } }, directives: function () { return [VirtualScrollDirective, ɵngcc2.NgIf, ɵngcc2.NgForOf, ɵngcc2.NgStyle, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet]; }, styles: [""], changeDetection: 0 });
/** @nocollapse */
GroupedOptionsComponent.ctorParameters = () => [
    { type: NgxMultiselectService }
];
GroupedOptionsComponent.propDecorators = {
    groupedProperty: [{ type: Input }],
    disabled: [{ type: Input }],
    multiple: [{ type: Input }],
    selectedOptions: [{ type: Input }],
    optionsTemplate: [{ type: Input }],
    options: [{ type: Input }],
    selectGroup: [{ type: Output }],
    selectOption: [{ type: Output }],
    defaultOptionsTemplate: [{ type: ViewChild, args: ['defaultOptionsTemplate', { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupedOptionsComponent, [{
        type: Component,
        args: [{
                selector: 'ms-grouped-options',
                template: "<div class=\"options-container\" msVirtualScroll [totalCount]=\"options.length\" (rangeChanged)=\"updateRange($event)\">\n  <div #top class=\"top\"></div>\n  <ng-container *ngIf=\"filteredOptions.length; else noOptions\">\n    <div\n      class=\"option\"\n      [ngStyle]=\"{ marginLeft: option.depth * 15 + 'px' }\"\n      [ngClass]=\"getOptionStyle(option)\"\n      *ngFor=\"let option of filteredOptions; trackBy: trackByFn\"\n      (click)=\"select(option)\"\n    >\n      <ng-container\n        *ngTemplateOutlet=\"\n          optionsTemplate;\n          context: {\n            option: option\n          }\n        \"\n      ></ng-container>\n    </div>\n  </ng-container>\n  <div #bottom class=\"bottom\"></div>\n</div>\n<ng-template #defaultOptionsTemplate let-option=\"option\">\n  {{ option?.name }}\n</ng-template>\n<ng-template #noOptions let-option=\"option\">\n  <div class=\"option message\">\n    No options available.\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            }]
    }], function () { return [{ type: NgxMultiselectService }]; }, { disabled: [{
            type: Input
        }], multiple: [{
            type: Input
        }], selectGroup: [{
            type: Output
        }], selectOption: [{
            type: Output
        }], selectedOptions: [{
            type: Input
        }], options: [{
            type: Input
        }], optionsTemplate: [{
            type: Input
        }], groupedProperty: [{
            type: Input
        }], defaultOptionsTemplate: [{
            type: ViewChild,
            args: ['defaultOptionsTemplate', { static: true }]
        }] }); })();
if (false) {
    /** @type {?} */
    GroupedOptionsComponent.prototype._options;
    /** @type {?} */
    GroupedOptionsComponent.prototype._selectedOptions;
    /** @type {?} */
    GroupedOptionsComponent.prototype.groupedOptions;
    /** @type {?} */
    GroupedOptionsComponent.prototype.start;
    /** @type {?} */
    GroupedOptionsComponent.prototype.end;
    /** @type {?} */
    GroupedOptionsComponent.prototype.filteredOptions;
    /** @type {?} */
    GroupedOptionsComponent.prototype.groupedProperty;
    /** @type {?} */
    GroupedOptionsComponent.prototype.disabled;
    /** @type {?} */
    GroupedOptionsComponent.prototype.multiple;
    /** @type {?} */
    GroupedOptionsComponent.prototype.optionsTemplate;
    /** @type {?} */
    GroupedOptionsComponent.prototype.selectGroup;
    /** @type {?} */
    GroupedOptionsComponent.prototype.selectOption;
    /** @type {?} */
    GroupedOptionsComponent.prototype.defaultOptionsTemplate;
    /** @type {?} */
    GroupedOptionsComponent.prototype.multiselectService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/virtual-scroll.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VirtualScrollDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.scrollOffset = 0;
        this.itemHeight = 40;
        this.rangeChanged = new EventEmitter();
        this.lastScrollFireTime = 0;
    }
    /**
     * @param {?} count
     * @return {?}
     */
    set totalCount(count) {
        this._totalCount = count;
        count ? this.initialSetup() : this.reset();
    }
    /**
     * @return {?}
     */
    get() {
        return this._totalCount;
    }
    /**
     * @return {?}
     */
    reset() {
        if (this.top && this.bottom) {
            this.renderer.setStyle(this.top, 'height', 0);
            this.renderer.setStyle(this.bottom, 'height', 0);
            this.renderer.setProperty(this.el.nativeElement, 'scrollTop', 0);
        }
    }
    /**
     * @param {?} target
     * @return {?}
     */
    throttleScroll(target) {
        const { scrollTop, clientHeight } = target;
        /** @type {?} */
        const totalHeight = this.itemHeight * this._totalCount + this.scrollOffset;
        // Step: 1 - Calculate the position
        /** @type {?} */
        const topSpacing = scrollTop;
        /** @type {?} */
        const maxItemsRange = (clientHeight - this.scrollOffset) / this.itemHeight;
        // Step: 2 - What are the possible collection that can be rendered
        /** @type {?} */
        const rangeOffset = topSpacing % this.itemHeight;
        /** @type {?} */
        const rangeStart = topSpacing - rangeOffset;
        /** @type {?} */
        const topNonVisible = topSpacing / this.itemHeight;
        /** @type {?} */
        const itemStartRange = Math.floor(topNonVisible);
        /** @type {?} */
        const rangeToBeIncreamented = rangeOffset ? maxItemsRange + 1 : maxItemsRange;
        /** @type {?} */
        const calculatedEndRange = itemStartRange + rangeToBeIncreamented;
        /** @type {?} */
        const itemEndRange = calculatedEndRange >= this._totalCount ? this._totalCount : calculatedEndRange;
        /** @type {?} */
        const bottomSpacing = totalHeight - (rangeStart + rangeToBeIncreamented * this.itemHeight);
        // Step: 3 - Pass the range to the child directive
        this.renderer.setStyle(this.top, 'height', `${rangeStart}px`);
        this.renderer.setStyle(this.bottom, 'height', `${bottomSpacing}px`);
        this.rangeChanged.emit({ start: itemStartRange, end: itemEndRange });
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    onscroll({ target }) {
        /** @type {?} */
        const minScrollTime = 50;
        /** @type {?} */
        const now = new Date().getTime();
        if (!this.scrollTimer) {
            if (now - this.lastScrollFireTime > minScrollTime) {
                this.lastScrollFireTime = now;
            }
            this.scrollTimer = setTimeout((/**
             * @return {?}
             */
            () => {
                this.scrollTimer = null;
                this.lastScrollFireTime = new Date().getTime();
                this.throttleScroll(target);
            }), minScrollTime);
        }
    }
    /**
     * @return {?}
     */
    initialSetup() {
        // TODO: later think of usng ViewChild, instead of direct DOM manipulation.
        const { scrollTop, clientHeight } = this.el.nativeElement;
        this.top = this.renderer.selectRootElement('.top');
        this.bottom = this.renderer.selectRootElement('.bottom');
        this.renderer.setStyle(this.top, 'height', `${scrollTop}px`);
        this.renderer.setStyle(this.bottom, 'height', `${this.itemHeight * this._totalCount + this.scrollOffset - clientHeight}px`);
        this.renderer.setProperty(this.el.nativeElement, 'scrollTop', 0);
    }
}
VirtualScrollDirective.ɵfac = function VirtualScrollDirective_Factory(t) { return new (t || VirtualScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
VirtualScrollDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VirtualScrollDirective, selectors: [["", "msVirtualScroll", ""]], hostBindings: function VirtualScrollDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function VirtualScrollDirective_scroll_HostBindingHandler($event) { return ctx.onscroll($event); });
    } }, inputs: { itemHeight: "itemHeight", totalCount: "totalCount" }, outputs: { rangeChanged: "rangeChanged" } });
/** @nocollapse */
VirtualScrollDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
VirtualScrollDirective.propDecorators = {
    itemHeight: [{ type: Input }],
    totalCount: [{ type: Input }],
    rangeChanged: [{ type: Output }],
    onscroll: [{ type: HostListener, args: ['scroll', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VirtualScrollDirective, [{
        type: Directive,
        args: [{
                selector: '[msVirtualScroll]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { itemHeight: [{
            type: Input
        }], rangeChanged: [{
            type: Output
        }], totalCount: [{
            type: Input
        }], 
    /**
     * @param {?} __0
     * @return {?}
     */
    onscroll: [{
            type: HostListener,
            args: ['scroll', ['$event']]
        }] }); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype._totalCount;
    /** @type {?} */
    VirtualScrollDirective.prototype.top;
    /** @type {?} */
    VirtualScrollDirective.prototype.bottom;
    /** @type {?} */
    VirtualScrollDirective.prototype.scrollOffset;
    /** @type {?} */
    VirtualScrollDirective.prototype.itemHeight;
    /** @type {?} */
    VirtualScrollDirective.prototype.rangeChanged;
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype.scrollTimer;
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype.lastScrollFireTime;
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    VirtualScrollDirective.prototype.renderer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/multiselect.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMultiselectModule {
}
NgxMultiselectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxMultiselectModule });
NgxMultiselectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxMultiselectModule_Factory(t) { return new (t || NgxMultiselectModule)(); }, imports: [[CommonModule, FormsModule, ReactiveFormsModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxMultiselectModule, { declarations: function () { return [NgxMultiselectComponent, DisplaySelectedValuePipe, HelperElementsComponent, FilterOptionsComponent, OptionsComponent, GroupedOptionsComponent, VirtualScrollDirective]; }, imports: function () { return [CommonModule, FormsModule, ReactiveFormsModule]; }, exports: function () { return [NgxMultiselectComponent, DisplaySelectedValuePipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMultiselectModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, FormsModule, ReactiveFormsModule],
                declarations: [
                    NgxMultiselectComponent,
                    DisplaySelectedValuePipe,
                    HelperElementsComponent,
                    FilterOptionsComponent,
                    OptionsComponent,
                    GroupedOptionsComponent,
                    VirtualScrollDirective
                ],
                exports: [NgxMultiselectComponent, DisplaySelectedValuePipe]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-lib-multiselect.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DEFAULT_VALUE_ACCESSOR, DisplaySelectedValuePipe, FilterOptionsComponent, GroupedOptionsComponent, HelperElementsComponent, NgxMultiselectComponent, NgxMultiselectModule, NgxMultiselectService, OptionsComponent, VirtualScrollDirective as ɵa };

//# sourceMappingURL=ngx-lib-multiselect.js.map