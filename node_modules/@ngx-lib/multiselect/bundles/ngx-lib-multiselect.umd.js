(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@ngx-lib/multiselect', ['exports', '@angular/core', '@angular/forms', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['ngx-lib'] = global['ngx-lib'] || {}, global['ngx-lib'].multiselect = {}), global.ng.core, global.ng.forms, global.ng.common));
}(this, (function (exports, i0, forms, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /** @type {?} */
    var matchSelectors = [
        'matches',
        'webkitMatchesSelector',
        'mozMatchesSelector',
        'msMatchesSelector',
        'oMatchesSelector'
    ];
    var NgxMultiselectService = /** @class */ (function () {
        function NgxMultiselectService() {
        }
        /**
         * @param {?} node
         * @param {?} selector
         * @return {?}
         */
        NgxMultiselectService.prototype.pseudoClassExist = function (node, selector) {
            /** @type {?} */
            var nativeMatches = node.matches || node.msMatchesSelector;
            try {
                return nativeMatches.call(node, selector);
            }
            catch (error) {
                return false;
            }
        };
        /**
         * @param {?} el
         * @param {?} selector
         * @return {?}
         */
        NgxMultiselectService.prototype.closest = function (el, selector) {
            /** @type {?} */
            var matchesFn;
            // find vendor prefix
            matchSelectors.some(( /**
             * @param {?} fn
             * @return {?}
             */function (fn) {
                if (typeof document.body[fn] === 'function') {
                    matchesFn = fn;
                    return true;
                }
                return false;
            }));
            /** @type {?} */
            var parent;
            // traverse parents
            while (el) {
                parent = el.parentElement;
                if (parent && parent[matchesFn](selector)) {
                    return parent;
                }
                el = parent;
            }
            return false;
        };
        // TODO: make this logic to work to find all descendant groups
        /**
         * @param {?} collection
         * @param {?} groupProperty
         * @param {?} groupName
         * @return {?}
         */
        NgxMultiselectService.prototype.collectAllDescendants = function (collection, groupProperty, groupName) {
            /** @type {?} */
            var allDescendants = collection.filter(( /**
             * @param {?} item
             * @return {?}
             */function (/**
             * @param {?} item
             * @return {?}
             */ item) { return item[groupProperty] == groupName; }));
            allDescendants.concat(collection.filter(( /**
             * @param {?} item
             * @return {?}
             */function (/**
             * @param {?} item
             * @return {?}
             */ item) { return item.parent == groupName; })));
            return allDescendants;
        };
        /**
         * @private
         * @param {?} collection
         * @param {?} groupProperty
         * @param {?} groupName
         * @return {?}
         */
        NgxMultiselectService.prototype.allDescendantsAreTicked = function (collection, groupProperty, groupName) {
            /** @type {?} */
            var allDescendants = this.collectAllDescendants(collection, groupProperty, groupName);
            /** @type {?} */
            var allAreTicked = allDescendants.every(( /**
             * @param {?} d
             * @return {?}
             */function (/**
             * @param {?} d
             * @return {?}
             */ d) { return d.ticked; }));
            return allAreTicked;
        };
        /**
         * @private
         * @param {?} collection
         * @param {?} groupProperty
         * @param {?} groupName
         * @return {?}
         */
        NgxMultiselectService.prototype.allDescendantsAreDisabled = function (collection, groupProperty, groupName) {
            /** @type {?} */
            var allDescendants = this.collectAllDescendants(collection, groupProperty, groupName);
            /** @type {?} */
            var allAreDisabled = allDescendants.every(( /**
             * @param {?} d
             * @return {?}
             */function (/**
             * @param {?} d
             * @return {?}
             */ d) { return d.disabled; }));
            return allAreDisabled;
        };
        /**
         * @param {?} options
         * @param {?} groupByProperty
         * @return {?}
         */
        NgxMultiselectService.prototype.optionsGrouping = function (options, groupByProperty) {
            /** @type {?} */
            var getAllUniqueGroupByPropertyValue = this.findUnique(options.map(( /**
             * @param {?} item
             * @return {?}
             */function (/**
             * @param {?} item
             * @return {?}
             */ item) { return item[groupByProperty]; })));
            /** @type {?} */
            var result = getAllUniqueGroupByPropertyValue.map(( /**
             * @param {?} group
             * @return {?}
             */function (/**
             * @param {?} group
             * @return {?}
             */ group) {
                /** @type {?} */
                var groupedValues = options.filter(( /**
                 * @param {?} o
                 * @return {?}
                 */function (/**
                 * @param {?} o
                 * @return {?}
                 */ o) { return o[groupByProperty] === group; }));
                return {
                    name: group,
                    values: groupedValues,
                    ticked: groupedValues.every(( /**
                     * @param {?} o
                     * @return {?}
                     */function (/**
                     * @param {?} o
                     * @return {?}
                     */ o) { return o.ticked; })),
                    disabled: groupedValues.every(( /**
                     * @param {?} o
                     * @return {?}
                     */function (/**
                     * @param {?} o
                     * @return {?}
                     */ o) { return o.disabled; }))
                };
            }));
            return result;
        };
        /**
         * @param {?} expression
         * @return {?}
         */
        NgxMultiselectService.prototype.findUnique = function (expression) {
            return __spread(Array.from(new Set(expression)));
        };
        /**
         * @param {?} options
         * @param {?} groupByProperty
         * @return {?}
         */
        NgxMultiselectService.prototype.virtualOptionsGroupingFlatten = function (options, groupByProperty) {
            var _this = this;
            /** @type {?} */
            var allParentGroupedValues = this.findUnique(options.filter(( /**
             * @param {?} o
             * @return {?}
             */function (/**
             * @param {?} o
             * @return {?}
             */ o) { return !o.parent; })).map(( /**
             * @param {?} item
             * @return {?}
             */function (/**
             * @param {?} item
             * @return {?}
             */ item) { return item[groupByProperty]; })));
            /** @type {?} */
            var subGroupedValues = this.findUnique(options.filter(( /**
             * @param {?} o
             * @return {?}
             */function (/**
             * @param {?} o
             * @return {?}
             */ o) { return o.parent; })).map(( /**
             * @param {?} __0
             * @return {?}
             */function (_a) {
                var name = _a.name, parent = _a.parent;
                return ({ name: name, parent: parent });
            })));
            /** @type {?} */
            var result = [];
            allParentGroupedValues.forEach(( /**
             * @param {?} group
             * @return {?}
             */function (/**
             * @param {?} group
             * @return {?}
             */ group) {
                result.push({
                    name: group,
                    isGroup: true,
                    ticked: _this.allDescendantsAreTicked(options, groupByProperty, group),
                    disabled: _this.allDescendantsAreDisabled(options, groupByProperty, group)
                });
                /** @type {?} */
                var groupedValues = options
                    .filter(( /**
             * @param {?} o
             * @return {?}
             */function (/**
             * @param {?} o
             * @return {?}
             */ o) { return o[groupByProperty] === group && !o.parent; }))
                    .map(( /**
             * @param {?} v
             * @return {?}
             */function (/**
             * @param {?} v
             * @return {?}
             */ v) { return (Object.assign(Object.assign({}, v), { depth: 1 })); }));
                result = __spread(result).concat(groupedValues);
                /** @type {?} */
                var childGroupedValues = subGroupedValues.filter(( /**
                 * @param {?} s
                 * @return {?}
                 */function (s) { return s.parent === group; }));
                childGroupedValues.forEach(( /**
                 * @param {?} c
                 * @return {?}
                 */function (/**
                 * @param {?} c
                 * @return {?}
                 */ c) {
                    result.push({ name: c, parent: group, isGroup: true });
                    /** @type {?} */
                    var values = options.filter(( /**
                     * @param {?} o
                     * @return {?}
                     */function (/**
                     * @param {?} o
                     * @return {?}
                     */ o) { return o[groupByProperty] === c; })).map(( /**
                     * @param {?} v
                     * @return {?}
                     */function (/**
                     * @param {?} v
                     * @return {?}
                     */ v) { return (Object.assign(Object.assign({}, v), { depth: 2 })); }));
                    result.concat(values);
                }));
            }));
            return result;
        };
        /**
         * @param {?} json
         * @return {?}
         */
        NgxMultiselectService.prototype.mirrorObject = function (json) {
            /** @type {?} */
            var ret = {};
            for (var key in json) {
                ret[json[key]] = key;
            }
            return ret;
        };
        /**
         * @param {?} collection
         * @param {?} propertyMap
         * @param {?=} groupedProperty
         * @return {?}
         */
        NgxMultiselectService.prototype.mapDatasourceToFields = function (collection, propertyMap, groupedProperty) {
            /** @type {?} */
            var keys = Object.keys(propertyMap);
            return collection.map(( /**
             * @param {?} item
             * @return {?}
             */function (item) {
                var _a;
                /** @type {?} */
                var obj = groupedProperty ? (_a = {}, _a[groupedProperty] = item[groupedProperty], _a) : {};
                keys.reduce(( /**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */function (a, b) {
                    obj[b] = item[propertyMap[b]];
                }), obj);
                return obj;
            }));
        };
        return NgxMultiselectService;
    }());
    NgxMultiselectService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NgxMultiselectService.ctorParameters = function () { return []; };
    /** @nocollapse */ NgxMultiselectService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgxMultiselectService_Factory() { return new NgxMultiselectService(); }, token: NgxMultiselectService, providedIn: "root" });

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filter-options/filter-options.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FilterOptionsComponent = /** @class */ (function () {
        function FilterOptionsComponent() {
            this.onSearchChange = new i0.EventEmitter();
        }
        /**
         * @return {?}
         */
        FilterOptionsComponent.prototype.clearInputFilter = function () {
            this.filterName.setValue('');
        };
        /**
         * @return {?}
         */
        FilterOptionsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.filterName = new forms.FormControl('');
            this.filterNameSubscription = this.filterName.valueChanges.subscribe(( /**
             * @param {?} val
             * @return {?}
             */function (/**
             * @param {?} val
             * @return {?}
             */ val) { return _this.onSearchChange.emit(val); }));
        };
        /**
         * @return {?}
         */
        FilterOptionsComponent.prototype.ngOnDestroy = function () {
            this.filterNameSubscription.unsubscribe();
        };
        return FilterOptionsComponent;
    }());
    FilterOptionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ms-filter-options',
                    template: "<div class=\"input-search\">\n  <div class=\"field-infix\">\n    <input\n      autofocus\n      placeholder=\"Search options here..\"\n      type=\"text\"\n      [formControl]=\"filterName\"\n      ngDefaultControl\n      class=\"input-filter\"\n    />\n  </div>\n  <div class=\"field-suffix\">\n    <button type=\"button\" [disabled]=\"!filterName.value\" (click)=\"clearInputFilter()\" class=\"clear-button\">X</button>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    styles: [".input-search{align-items:stretch;display:flex;flex-grow:1;height:30px;padding:2px}.mat-multiselect :host ::ng-deep .input-search{border-bottom:1px solid rgba(0,0,0,.12)}.mat-multiselect :host ::ng-deep .input-filter{border:none;flex-grow:1;font:inherit;outline:none}.mat-multiselect :host ::ng-deep .field-infix{display:flex;flex:1;padding:5px}.mat-multiselect :host ::ng-deep .field-suffix{margin:3px;white-space:nowrap}.mat-multiselect :host ::ng-deep .field-suffix button{border:none;border-radius:10px;font-size:inherit;height:20px;min-width:20px;padding:0;width:20px}.bs-multiselect :host ::ng-deep .clear-button{background-color:#f1f1f1;border:none;border-radius:2px;color:#666;cursor:pointer;font-size:inherit;max-width:20px;min-width:20px;padding:0}.bs-multiselect :host ::ng-deep .input-filter{border:1px solid #ccc;border-radius:2px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-sizing:border-box;color:#666;cursor:pointer;font-size:inherit;height:30px;height:100%;padding-left:7px;width:100%}.bs-multiselect :host ::ng-deep .field-infix{display:flex;flex-grow:1}.bs-multiselect :host ::ng-deep .field-suffix{display:flex}"]
                }] }
    ];
    /** @nocollapse */
    FilterOptionsComponent.ctorParameters = function () { return []; };
    FilterOptionsComponent.propDecorators = {
        onSearchChange: [{ type: i0.Output }]
    };
    if (false) {
        /** @type {?} */
        FilterOptionsComponent.prototype.filterName;
        /** @type {?} */
        FilterOptionsComponent.prototype.filterNameSubscription;
        /** @type {?} */
        FilterOptionsComponent.prototype.onSearchChange;
    }

    /** @type {?} */
    var DEFAULT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(( /**
         * @return {?}
         */function () { return NgxMultiselectComponent; })),
        multi: true
    };
    var NgxMultiselectComponent = /** @class */ (function () {
        /**
         * @param {?} elementRef
         * @param {?} multiselectService
         */
        function NgxMultiselectComponent(elementRef, multiselectService) {
            var _this = this;
            this.elementRef = elementRef;
            this.multiselectService = multiselectService;
            this._theme = 'material';
            this._isOpen = false;
            this.operationPendingQueue = [];
            // public variables
            this._selectedOptions = null;
            this._defaultPropertyMap = {
                id: 'id',
                name: 'name',
                disabled: 'disabled'
            };
            this._defaultPropertyMapLength = Object.keys(this._defaultPropertyMap).length;
            this.matMultiselect = true;
            this.bsMultiselect = false;
            // Input bindings
            this.disabled = false;
            this.color = 'blue';
            this.showHelperElements = true;
            this.showSearchFilter = true;
            this.showMaxLabels = 3;
            // Output bindings
            this.onOpen = new i0.EventEmitter();
            this.onClose = new i0.EventEmitter();
            this.onItemClick = new i0.EventEmitter();
            this.onGroupItemClick = new i0.EventEmitter();
            this.onSelectAll = new i0.EventEmitter();
            this.onSelectNone = new i0.EventEmitter();
            this.onReset = new i0.EventEmitter();
            this.onClear = new i0.EventEmitter();
            this.onSearchChange = new i0.EventEmitter();
            this.onChange = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { });
            this.onTouched = ( /**
             * @return {?}
             */function () { });
            this.filterOptionsList = ( /**
             * @param {?} val
             * @return {?}
             */function (val) {
                /** @type {?} */
                var optionsCopy = _this.getOptionsCopy();
                /** @type {?} */
                var result = optionsCopy;
                if (val) {
                    result = optionsCopy.filter(( /**
                     * @param {?} i
                     * @return {?}
                     */function (/**
                     * @param {?} i
                     * @return {?}
                     */ i) { return i.name && i.name.toLowerCase().indexOf(val.toLowerCase()) !== -1; }));
                }
                _this.setOptions(result);
                _this.prepopulateOptions(_this._selectedOptions);
            });
        }
        Object.defineProperty(NgxMultiselectComponent.prototype, "optionsTemplate", {
            /**
             * @return {?}
             */
            get: function () {
                return this._optionsTemplate;
            },
            /**
             * @param {?} template
             * @return {?}
             */
            set: function (template) {
                this._optionsTemplate = template;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMultiselectComponent.prototype, "theme", {
            /**
             * @return {?}
             */
            get: function () {
                return this._theme;
            },
            /**
             * @param {?} val
             * @return {?}
             */
            set: function (val) {
                this._theme = val;
                this.matMultiselect = val === 'material';
                this.bsMultiselect = val === 'bootstrap';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMultiselectComponent.prototype, "isOpen", {
            /**
             * @return {?}
             */
            get: function () {
                return this._isOpen;
            },
            // Input binding with getter / setter
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._isOpen = value;
                // onOpen and onClose event will be fired by isOpen setter
                if (value) {
                    // list populate, based on empty value
                    this.filterOptionsList('');
                    this.onTouched();
                    this.onOpen.emit();
                }
                else {
                    this.onClose.emit();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMultiselectComponent.prototype, "propertyMap", {
            /**
             * @param {?} val
             * @return {?}
             */
            set: function (val) {
                this._defaultPropertyMap = Object.assign(Object.assign({}, this._defaultPropertyMap), val);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMultiselectComponent.prototype, "multiple", {
            /**
             * @return {?}
             */
            get: function () {
                return this._multiple;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this.viewToModel(value ? [] : null);
                this._multiple = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMultiselectComponent.prototype, "options", {
            /**
             * @param {?} collection
             * @return {?}
             */
            set: function (collection) {
                if (!collection)
                    return;
                this._optionsCopy = this.multiselectService.mapDatasourceToFields(collection, this._defaultPropertyMap, this.groupedProperty);
                /** @type {?} */
                var options = this.getOptionsCopy();
                this.setOptions(options);
                // Sometimes binding can happens lazily, 
                // so `finishPendingOperations` helps to execute such operations
                if (this.isOperationPending())
                    this.finishPendingOperations();
            },
            enumerable: false,
            configurable: true
        });
        // Adding pending operation in queue
        /**
         * @param {?} item
         * @return {?}
         */
        NgxMultiselectComponent.prototype.addOperation = function (item) {
            this.operationPendingQueue.push(item);
        };
        // Poping pending operation from queue sequentially
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.popOperation = function () {
            return this.operationPendingQueue.pop();
        };
        /*
            In future this code is going to resides inside different Service,
            This pendingOperation feature is fine grained in future,
            and can be used for multiple purpose like model update, collection update, etc.
          */
        // Extracting and finishing all pending operation
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.finishPendingOperations = function () {
            /** @type {?} */
            var operation = this.popOperation();
            this.prepopulateOptions(operation);
        };
        // Check pending operation queue status
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.isOperationPending = function () {
            return this.operationPendingQueue.length;
        };
        Object.defineProperty(NgxMultiselectComponent.prototype, "initialValue", {
            /**
             * @return {?}
             */
            get: function () {
                return this._initialValue;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._initialValue = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        NgxMultiselectComponent.prototype.writeValue = function (value) {
            // Set selected value for initial load of value
            if (value) {
                this.initialValue = value;
                this._options ? this.prepopulateOptions(value) : this.addOperation(value);
                this.formatPrepopulatedValues(value);
            }
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NgxMultiselectComponent.prototype.formatPrepopulatedValues = function (value) {
            /** @type {?} */
            var options = value;
            // TODO: can we improve below logic?
            if (Object.keys(this._defaultPropertyMap).length == this._defaultPropertyMapLength)
                return;
            /** @type {?} */
            var swappedPropertyMap = this.multiselectService.mirrorObject(this._defaultPropertyMap);
            if (this.multiple) {
                options.forEach(( /**
                 * @param {?} o
                 * @return {?}
                 */function (/**
                 * @param {?} o
                 * @return {?}
                 */ o) {
                    o.id = o[swappedPropertyMap.id];
                    o.name = o[swappedPropertyMap.name];
                }));
            }
            else {
                value.id = value[swappedPropertyMap.id];
                value.name = value[swappedPropertyMap.name];
                options = value;
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NgxMultiselectComponent.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NgxMultiselectComponent.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        // All update to options should happen from below method.
        /**
         * @param {?} options
         * @return {?}
         */
        NgxMultiselectComponent.prototype.setOptions = function (options) {
            this._options = options;
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.getOptions = function () {
            return this._options ? __spread(this._options) : [];
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.getOptionsCopy = function () {
            return this._optionsCopy ? __spread(this._optionsCopy) : [];
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.isValueSelected = function () {
            return this._selectedOptions && this._multiple ?
                this._selectedOptions.length :
                this._selectedOptions;
        };
        /**
         * @param {?} val
         * @return {?}
         */
        NgxMultiselectComponent.prototype.searchChange = function (val) {
            this.filterOptionsList(val);
            this.onSearchChange.emit(val);
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.close = function () {
            this.isOpen = false;
        };
        /**
         * @param {?} collection
         * @param {?} item
         * @return {?}
         */
        NgxMultiselectComponent.prototype.removeItem = function (collection, item) {
            item.ticked = false;
            /** @type {?} */
            var index = collection.findIndex(( /**
             * @param {?} o
             * @return {?}
             */function (/**
             * @param {?} o
             * @return {?}
             */ o) { return o.id === item.id; }));
            collection.splice(index, 1);
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.toggleDropdown = function () {
            this.isOpen = !this.isOpen;
        };
        /**
         * @param {?} selected
         * @return {?}
         */
        NgxMultiselectComponent.prototype.prepopulateOptions = function (selected) {
            /** @type {?} */
            var selectedIds = [];
            selectedIds = this._multiple ?
                (selected || []).map(( /**
                 * @param {?} i
                 * @return {?}
                 */function (/**
                 * @param {?} i
                 * @return {?}
                 */ i) { return i.id; })) :
                selected ? [selected.id] : [];
            this.setOptions(this.getOptions()
                .map(( /**
         * @param {?} o
         * @return {?}
         */function (/**
         * @param {?} o
         * @return {?}
         */ o) { return (Object.assign(Object.assign({}, o), { ticked: selectedIds.indexOf(o.id) !== -1 })); })));
            // TODO: do we really need this reassignment?
            this.viewToModel(selected);
        };
        /**
         * @param {?} option
         * @return {?}
         */
        NgxMultiselectComponent.prototype.select = function (option) {
            /** @type {?} */
            var selectedOptions;
            option.ticked = !option.ticked;
            // TODO: Refactor below logic
            if (this._multiple) {
                selectedOptions = __spread(this._selectedOptions);
                /** @type {?} */
                var selectedIds = selectedOptions.map(( /**
                 * @param {?} i
                 * @return {?}
                 */function (/**
                 * @param {?} i
                 * @return {?}
                 */ i) { return i.id; }));
                if (selectedIds.indexOf(option.id) === -1) {
                    // if selected item not exist in collection, push it
                    selectedOptions.push(option);
                }
                else {
                    // if selected item exist in collection, post it
                    this.removeItem(selectedOptions, option);
                }
                selectedIds = selectedOptions.map(( /**
                 * @param {?} i
                 * @return {?}
                 */function (/**
                 * @param {?} i
                 * @return {?}
                 */ i) { return i.id; }));
            }
            else {
                // TODO: find optimized way to do below
                /** @type {?} */
                var val_1 = option && option.id;
                /** @type {?} */
                var changedOptions = this.getOptions()
                    .map(( /**
             * @param {?} o
             * @return {?}
             */function (/**
             * @param {?} o
             * @return {?}
             */ o) { return (Object.assign(Object.assign({}, o), { ticked: o.id == val_1 })); }));
                selectedOptions = changedOptions.find(( /**
                 * @param {?} i
                 * @return {?}
                 */function (/**
                 * @param {?} i
                 * @return {?}
                 */ i) { return i.ticked; }));
                this.setOptions(changedOptions);
                this.close();
            }
            this.viewToModel(selectedOptions);
            this.onItemClick.emit(option);
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.selectAll = function () {
            /** @type {?} */
            var allSelectedOptions = this.getOptions()
                .map(( /**
         * @param {?} o
         * @return {?}
         */function (/**
         * @param {?} o
         * @return {?}
         */ o) { return (Object.assign(Object.assign({}, o), { ticked: true })); }));
            this.setOptions(allSelectedOptions);
            this.viewToModel(allSelectedOptions);
            this.onSelectAll.emit();
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.selectNone = function () {
            /** @type {?} */
            var options = this.getOptions().map(( /**
             * @param {?} o
             * @return {?}
             */function (/**
             * @param {?} o
             * @return {?}
             */ o) { return (Object.assign(Object.assign({}, o), { ticked: false })); }));
            this.setOptions(options);
            this.viewToModel([]);
            this.onSelectNone.emit();
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.borderBottom = function () {
            return this._isOpen ? { borderBottom: "1px solid " + (this.matMultiselect ? this.color : 'transperant') } : {};
        };
        //TODO: Optimized below logic, it can be done in lesser steps
        /**
         * @param {?} group
         * @return {?}
         */
        NgxMultiselectComponent.prototype.selectGroup = function (group) {
            var ticked = group.ticked, values = group.values;
            /** @type {?} */
            var options = this.getOptions();
            /** @type {?} */
            var selectedValues = __spread(this._selectedOptions);
            /** @type {?} */
            var selectedIds = selectedValues.map(( /**
             * @param {?} s
             * @return {?}
             */function (/**
             * @param {?} s
             * @return {?}
             */ s) { return s.id; }));
            /** @type {?} */
            var allGroupOptionIds = values.map(( /**
             * @param {?} v
             * @return {?}
             */function (/**
             * @param {?} v
             * @return {?}
             */ v) { return v.id; }));
            // Get all ticked options
            // concat with selected options
            selectedValues = ticked
                ? selectedValues.concat(values)
                : selectedValues.filter(( /**
                 * @param {?} o
                 * @return {?}
                 */function (/**
                 * @param {?} o
                 * @return {?}
                 */ o) { return allGroupOptionIds.indexOf(o.id) === -1; }));
            // Find unique out of them
            selectedIds = this.multiselectService.findUnique(selectedValues.map(( /**
             * @param {?} item
             * @return {?}
             */function (/**
             * @param {?} item
             * @return {?}
             */ item) { return item.id; })));
            // build selectedOptions array again
            selectedValues = options.filter(( /**
             * @param {?} o
             * @return {?}
             */function (/**
             * @param {?} o
             * @return {?}
             */ o) { return selectedIds.indexOf(o.id) !== -1; }));
            this.viewToModel(selectedValues);
            this.onGroupItemClick.emit(group);
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.reset = function () {
            this.viewToModel(this.initialValue);
            this.prepopulateOptions(this.initialValue);
            this.onReset.emit();
        };
        // Responsible for updating value from view to model
        /**
         * @param {?} selected
         * @return {?}
         */
        NgxMultiselectComponent.prototype.viewToModel = function (selected) {
            if (this._selectedOptions !== selected) {
                this._selectedOptions = selected;
                this.onChange(selected);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NgxMultiselectComponent.prototype.clear = function (event) {
            /** @type {?} */
            var changedOptions = this.getOptions().map(( /**
             * @param {?} o
             * @return {?}
             */function (/**
             * @param {?} o
             * @return {?}
             */ o) { return (Object.assign(Object.assign({}, o), { ticked: false })); }));
            this.setOptions(changedOptions);
            // no value is selected so passing null
            this.viewToModel(null);
            this.onClear.emit();
            this.close();
            event.stopPropagation();
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NgxMultiselectComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * @return {?}
         */
        NgxMultiselectComponent.prototype.ngOnInit = function () {
            // Check if value have not been assigned then default to true
            if (typeof this._multiple === 'undefined') {
                this.multiple = true;
            }
        };
        // TODO: Consider creating a directive for this.
        // TODO: Also convert below to be work for element specific
        /**
         * @param {?} event
         * @return {?}
         */
        NgxMultiselectComponent.prototype.clickOutSide = function (event) {
            if (this.isOpen &&
                this.elementRef.nativeElement !== event &&
                !this.multiselectService.closest(event, 'ngx-multiselect')) {
                this.close();
            }
        };
        return NgxMultiselectComponent;
    }());
    NgxMultiselectComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ngx-multiselect',
                    template: "<div class=\"multiselect-wrapper\">\n  <button class=\"dropdown-button\" (click)=\"toggleDropdown()\" [ngClass]=\"{ open: isOpen }\">\n    <div class=\"selection\" [ngStyle]=\"borderBottom()\">\n      <!-- TODO: None selected template should be ng-template -->\n      <span class=\"none-selected\" *ngIf=\"!isValueSelected()\">None selected</span>\n      <span class=\"selected\" *ngIf=\"isValueSelected()\">\n        <span class=\"text\">{{_selectedOptions | displaySelectedValue: showMaxLabels}}</span>\n      </span>\n      <div class=\"symbols\">\n        <span class=\"close\" (click)=\"clear($event)\" *ngIf=\"isValueSelected() && !multiple\">\u00D7</span>\n        <span class=\"caret\"></span>\n      </div>\n    </div>\n  </button>\n  <div class=\"listing-wrapper\" *ngIf=\"isOpen\">\n    <ms-helper-elements\n      *ngIf=\"showHelperElements\"\n      [multiple]=\"multiple\"\n      [disabled]=\"disabled\"\n      (onClear)=\"onClear.emit()\"\n      (resetClicked)=\"reset()\"\n      (onSearchChange)=\"onSearchChange.emit($event)\"\n      (selectNoneClicked)=\"selectNone()\"\n      (selectAllClicked)=\"selectAll()\"\n      (selectNoneClicked)=\"selectNone()\"\n    >\n    </ms-helper-elements>\n    <ms-filter-options\n      *ngIf=\"showSearchFilter\"\n      #filterOptions\n      (onSearchChange)=\"searchChange($event)\"\n    ></ms-filter-options>\n    <ng-container *ngIf=\"!groupedProperty; else groupedTemplate\">\n      <ms-options\n        [optionsTemplate]=\"optionsTemplate\"\n        [options]=\"_options\"\n        [disabled]=\"disabled\"\n        (selectOption)=\"select($event)\"\n      ></ms-options>\n    </ng-container>\n  </div>\n</div>\n<ng-template #groupedTemplate>\n  <ms-grouped-options\n    [multiple]=\"multiple\"\n    [optionsTemplate]=\"optionsTemplate\"\n    [selectedOptions]=\"_selectedOptions\"\n    [options]=\"_options\"\n    [disabled]=\"disabled\"\n    [groupedProperty]=\"groupedProperty\"\n    (selectOption)=\"select($event)\"\n    (selectGroup)=\"selectGroup($event)\"\n  >\n  </ms-grouped-options>\n</ng-template>\n",
                    providers: [DEFAULT_VALUE_ACCESSOR],
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:inline-block;outline:none}.multiselect-wrapper{display:flex;flex-grow:1;width:240px}.selection{flex-grow:1;justify-content:space-between}.selection,.symbols{align-items:center;display:flex}.symbols{justify-content:flex-end}.symbols .caret{border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid}.dropdown-button{-moz-user-select:none;-ms-user-select:none;-o-user-select:none;-webkit-user-select:none;background-color:#fff;border:none;cursor:pointer;display:flex;flex-grow:1;font-size:inherit;min-height:39px;padding:5px;user-select:none;white-space:normal}.listing-wrapper{background-color:#fff;border:1px solid rgba(0,0,0,.15);border-radius:4px;box-shadow:0 6px 12px rgba(0,0,0,.175);position:absolute;width:inherit;z-index:999}::ng-deep .options-container{height:200px;overflow-y:scroll}:host.mat-multiselect ::ng-deep .option{-webkit-tap-highlight-color:transparent;align-items:center;border-left:.5px solid #eee;display:flex;flex-flow:row;height:40px;max-height:40px;outline:0;overflow:hidden;padding:0 6px;text-overflow:ellipsis;white-space:nowrap}:host.mat-multiselect ::ng-deep .option.marked,:host.mat-multiselect ::ng-deep .option.marked:hover,:host.mat-multiselect ::ng-deep .option:hover:not(.message){background-image:linear-gradient(#e9e9e9,#f1f1f1);color:#555;cursor:pointer;justify-content:space-between}:host.mat-multiselect ::ng-deep .marked:after{content:\"\u2713\"}:host.mat-multiselect ::ng-deep .option.disabled,:host.mat-multiselect ::ng-deep .option.disabled:hover:not(.message),:host.mat-multiselect ::ng-deep .option.disabled label input:hover~span{color:#c4c4c4!important;cursor:not-allowed!important;pointer-events:none}:host.mat-multiselect ::ng-deep .none-selected{-webkit-text-fill-color:#7a7a7a;color:#7a7a7a;transition:none}:host.mat-multiselect ::ng-deep .dropdown-button{color:#000}:host.mat-multiselect ::ng-deep .selection{border-bottom:1px solid #000;color:#000;padding-bottom:10px}:host.mat-multiselect ::ng-deep .open .selection{border-bottom:1px solid #00f}:host.bs-multiselect ::ng-deep .marked{background-color:green}:host.bs-multiselect ::ng-deep .dropdown-button{background-image:linear-gradient(#fff,#f7f7f7);border:1px solid #c6c6c6;border-radius:4px;color:#555}:host.bs-multiselect ::ng-deep .option{align-items:center;background-color:transparent;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);color:#555;display:flex;font-size:inherit;height:40px;max-height:40px;padding:0 6px}:host.bs-multiselect ::ng-deep .option:hover{background-image:linear-gradient(#c1c1c1,#999)!important;color:#fff!important;cursor:pointer}:host.bs-multiselect ::ng-deep .option.marked{background-image:linear-gradient(#e9e9e9,#f1f1f1);color:#555;cursor:pointer;display:flex;justify-content:space-between}:host.bs-multiselect ::ng-deep .marked:after{content:\"\u2713\";width:15px}:host.bs-multiselect ::ng-deep .option.disabled,:host.bs-multiselect ::ng-deep .option.disabled:hover,:host.bs-multiselect ::ng-deep .option.disabled label input:hover~span{color:#c4c4c4!important;cursor:not-allowed!important;pointer-events:none}"]
                }] }
    ];
    /** @nocollapse */
    NgxMultiselectComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: NgxMultiselectService }
    ]; };
    NgxMultiselectComponent.propDecorators = {
        matMultiselect: [{ type: i0.HostBinding, args: ['class.mat-multiselect',] }],
        bsMultiselect: [{ type: i0.HostBinding, args: ['class.bs-multiselect',] }],
        disabled: [{ type: i0.Input }],
        color: [{ type: i0.Input }],
        groupedProperty: [{ type: i0.Input }],
        showHelperElements: [{ type: i0.Input }],
        showSearchFilter: [{ type: i0.Input }],
        showMaxLabels: [{ type: i0.Input }],
        _optionsTemplate: [{ type: i0.ContentChild, args: [i0.TemplateRef,] }],
        optionsTemplate: [{ type: i0.Input }],
        theme: [{ type: i0.Input }],
        isOpen: [{ type: i0.Input }],
        propertyMap: [{ type: i0.Input }],
        multiple: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        onOpen: [{ type: i0.Output }],
        onClose: [{ type: i0.Output }],
        onItemClick: [{ type: i0.Output }],
        onGroupItemClick: [{ type: i0.Output }],
        onSelectAll: [{ type: i0.Output }],
        onSelectNone: [{ type: i0.Output }],
        onReset: [{ type: i0.Output }],
        onClear: [{ type: i0.Output }],
        onSearchChange: [{ type: i0.Output }],
        filterOptions: [{ type: i0.ViewChild, args: ['filterOptions', { read: FilterOptionsComponent },] }],
        clickOutSide: [{ type: i0.HostListener, args: ['document:click', ['$event.target'],] }]
    };
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NgxMultiselectComponent.prototype._multiple;
        /**
         * @type {?}
         * @private
         */
        NgxMultiselectComponent.prototype._theme;
        /**
         * @type {?}
         * @private
         */
        NgxMultiselectComponent.prototype._optionsCopy;
        /**
         * @type {?}
         * @private
         */
        NgxMultiselectComponent.prototype._isOpen;
        /**
         * @type {?}
         * @private
         */
        NgxMultiselectComponent.prototype.operationPendingQueue;
        /** @type {?} */
        NgxMultiselectComponent.prototype._selectedOptions;
        /** @type {?} */
        NgxMultiselectComponent.prototype._defaultPropertyMap;
        /** @type {?} */
        NgxMultiselectComponent.prototype._defaultPropertyMapLength;
        /** @type {?} */
        NgxMultiselectComponent.prototype._options;
        /** @type {?} */
        NgxMultiselectComponent.prototype.matMultiselect;
        /** @type {?} */
        NgxMultiselectComponent.prototype.bsMultiselect;
        /** @type {?} */
        NgxMultiselectComponent.prototype.disabled;
        /** @type {?} */
        NgxMultiselectComponent.prototype.color;
        /** @type {?} */
        NgxMultiselectComponent.prototype.groupedProperty;
        /** @type {?} */
        NgxMultiselectComponent.prototype.showHelperElements;
        /** @type {?} */
        NgxMultiselectComponent.prototype.showSearchFilter;
        /** @type {?} */
        NgxMultiselectComponent.prototype.showMaxLabels;
        /** @type {?} */
        NgxMultiselectComponent.prototype._optionsTemplate;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onOpen;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onClose;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onItemClick;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onGroupItemClick;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onSelectAll;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onSelectNone;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onReset;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onClear;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onSearchChange;
        /** @type {?} */
        NgxMultiselectComponent.prototype.filterOptions;
        /**
         * @type {?}
         * @private
         */
        NgxMultiselectComponent.prototype._initialValue;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onChange;
        /** @type {?} */
        NgxMultiselectComponent.prototype.onTouched;
        /** @type {?} */
        NgxMultiselectComponent.prototype.filterOptionsList;
        /**
         * @type {?}
         * @private
         */
        NgxMultiselectComponent.prototype.elementRef;
        /**
         * @type {?}
         * @private
         */
        NgxMultiselectComponent.prototype.multiselectService;
    }

    /** @type {?} */
    var DOTS = ' ...';
    var DisplaySelectedValuePipe = /** @class */ (function () {
        function DisplaySelectedValuePipe() {
            this.defaultMaxLabelCount = 3;
        }
        /**
         * @param {?} value
         * @param {?=} maxLabelCount
         * @return {?}
         */
        DisplaySelectedValuePipe.prototype.transform = function (value, maxLabelCount) {
            if (maxLabelCount === void 0) { maxLabelCount = this.defaultMaxLabelCount; }
            if (value instanceof Array) {
                /** @type {?} */
                var collection = __spread(value);
                /** @type {?} */
                var total = collection.length;
                /** @type {?} */
                var condn = collection.length > maxLabelCount;
                condn ? (collection.length = maxLabelCount) : null;
                return "" + collection.map(( /**
                 * @param {?} v
                 * @return {?}
                 */function (/**
                 * @param {?} v
                 * @return {?}
                 */ v) { return v.name; })).join(', ') + (condn ? DOTS + ' (' + total + ')' : '');
            }
            return value && value.name;
        };
        return DisplaySelectedValuePipe;
    }());
    DisplaySelectedValuePipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'displaySelectedValue',
                    pure: false
                },] }
    ];
    if (false) {
        /** @type {?} */
        DisplaySelectedValuePipe.prototype.defaultMaxLabelCount;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/helper-elements/helper-elements.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HelperElementsComponent = /** @class */ (function () {
        function HelperElementsComponent() {
            this.multiple = false;
            this.disabled = false;
            this.selectAllClicked = new i0.EventEmitter();
            this.selectNoneClicked = new i0.EventEmitter();
            this.resetClicked = new i0.EventEmitter();
        }
        /**
         * @return {?}
         */
        HelperElementsComponent.prototype.selectAll = function () {
            this.selectAllClicked.emit();
        };
        /**
         * @return {?}
         */
        HelperElementsComponent.prototype.selectNone = function () {
            this.selectNoneClicked.emit();
        };
        /**
         * @return {?}
         */
        HelperElementsComponent.prototype.reset = function () {
            this.resetClicked.emit();
        };
        return HelperElementsComponent;
    }());
    HelperElementsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ms-helper-elements',
                    template: "<div class=\"helper-buttons\">\n  <fieldset [disabled]=\"disabled\">\n    <ng-container *ngIf=\"multiple\">\n      <button class=\"helper-button\" (click)=\"selectAll()\">\u2713 Select All</button>\n      <button class=\"helper-button\" (click)=\"selectNone()\">\u00D7 Select None</button>\n    </ng-container>\n    <button class=\"helper-button\" (click)=\"reset()\">\u21B6 Reset</button>\n  </fieldset>\n</div>",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    styles: [".helper-button{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;border:1px solid rgba(0,0,0,.12);border-radius:.25rem;font-size:.75rem;font-weight:400;height:30px;max-height:30px;user-select:none;white-space:nowrap}fieldset{border:none;padding:0}.helper-buttons{border-bottom:1px solid #ddd;padding:2px}.mat-multiselect :host .helper-button{background-color:transparent;color:#444}.mat-multiselect :host .helper-button:not(:last-child){margin:0 2px}.bs-multiselect :host .helper-button{-webkit-tap-highlight-color:transparent;box-sizing:border-box;cursor:pointer;outline:0;padding:.25em}.bs-multiselect .helper-button:not(:last-child){margin-right:4px}"]
                }] }
    ];
    /** @nocollapse */
    HelperElementsComponent.ctorParameters = function () { return []; };
    HelperElementsComponent.propDecorators = {
        multiple: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        selectAllClicked: [{ type: i0.Output }],
        selectNoneClicked: [{ type: i0.Output }],
        resetClicked: [{ type: i0.Output }]
    };
    if (false) {
        /** @type {?} */
        HelperElementsComponent.prototype.multiple;
        /** @type {?} */
        HelperElementsComponent.prototype.disabled;
        /** @type {?} */
        HelperElementsComponent.prototype.selectAllClicked;
        /** @type {?} */
        HelperElementsComponent.prototype.selectNoneClicked;
        /** @type {?} */
        HelperElementsComponent.prototype.resetClicked;
    }

    var OptionsComponent = /** @class */ (function () {
        function OptionsComponent() {
            this._options = [];
            this.disabled = false;
            this.selectOption = new i0.EventEmitter();
            this.start = 0;
            this.end = 5;
        }
        Object.defineProperty(OptionsComponent.prototype, "options", {
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._options = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        OptionsComponent.prototype.get = function () {
            return this._options;
        };
        /**
         * @param {?} option
         * @return {?}
         */
        OptionsComponent.prototype.getOptionStyle = function (option) {
            return { marked: option.ticked, disabled: this.disabled || option.disabled };
        };
        /**
         * @param {?} option
         * @return {?}
         */
        OptionsComponent.prototype.select = function (option) {
            this.selectOption.emit(option);
        };
        /**
         * @param {?} __0
         * @return {?}
         */
        OptionsComponent.prototype.updateRange = function (_a) {
            var start = _a.start, end = _a.end;
            this.filteredOptions = __spread(this._options).slice(start, end);
        };
        /**
         * @return {?}
         */
        OptionsComponent.prototype.ngOnInit = function () {
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        OptionsComponent.prototype.ngOnChanges = function (changes) {
            var options = changes.options;
            if (!this.optionsTemplate) {
                this.optionsTemplate = this.defaultOptionsTemplate;
            }
            if (options.currentValue !== options.previousValue) {
                this.updateRange({ start: this.start, end: this.end });
            }
        };
        return OptionsComponent;
    }());
    OptionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ms-options',
                    template: "<div class=\"options-container\" msVirtualScroll [totalCount]=\"_options?.length\" (rangeChanged)=\"updateRange($event)\">\n  <div #top class=\"top\"></div>\n  <ng-container *ngIf=\"filteredOptions.length; else noOptions\">\n    <div\n      class=\"option\"\n      [ngClass]=\"getOptionStyle(option)\"\n      *ngFor=\"let option of filteredOptions\"\n      (click)=\"select(option)\"\n    >\n      <ng-container\n        *ngTemplateOutlet=\"\n          optionsTemplate;\n          context: {\n            option: option\n          }\n        \"\n      ></ng-container>\n    </div>\n  </ng-container>\n  <div #bottom class=\"bottom\"></div>\n</div>\n<ng-template #defaultOptionsTemplate let-option=\"option\">\n  {{ option.name }}\n</ng-template>\n<ng-template #noOptions let-option=\"option\">\n  <div class=\"option message\">\n    No options available.\n  </div>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    OptionsComponent.ctorParameters = function () { return []; };
    OptionsComponent.propDecorators = {
        disabled: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        optionsTemplate: [{ type: i0.Input }],
        selectOption: [{ type: i0.Output }],
        defaultOptionsTemplate: [{ type: i0.ViewChild, args: ['defaultOptionsTemplate', { static: true },] }]
    };
    if (false) {
        /** @type {?} */
        OptionsComponent.prototype._options;
        /** @type {?} */
        OptionsComponent.prototype.disabled;
        /** @type {?} */
        OptionsComponent.prototype.optionsTemplate;
        /** @type {?} */
        OptionsComponent.prototype.selectOption;
        /** @type {?} */
        OptionsComponent.prototype.start;
        /** @type {?} */
        OptionsComponent.prototype.end;
        /** @type {?} */
        OptionsComponent.prototype.filteredOptions;
        /** @type {?} */
        OptionsComponent.prototype.defaultOptionsTemplate;
    }

    var GroupedOptionsComponent = /** @class */ (function () {
        /**
         * @param {?} multiselectService
         */
        function GroupedOptionsComponent(multiselectService) {
            this.multiselectService = multiselectService;
            this._options = [];
            this._selectedOptions = [];
            this.groupedOptions = [];
            this.start = 0;
            this.end = 5;
            this.disabled = false;
            this.multiple = false;
            this.selectGroup = new i0.EventEmitter();
            this.selectOption = new i0.EventEmitter();
        }
        Object.defineProperty(GroupedOptionsComponent.prototype, "selectedOptions", {
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._selectedOptions = value;
                this.formGroupOptions(this._options, this._selectedOptions);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(GroupedOptionsComponent.prototype, "options", {
            /**
             * @return {?}
             */
            get: function () {
                return this.groupedOptions;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._options = value;
                this.formGroupOptions(value, this._selectedOptions);
            },
            enumerable: false,
            configurable: true
        });
        // TODO: Refactor below logic
        /**
         * @param {?} collection
         * @param {?} selectedOptions
         * @return {?}
         */
        GroupedOptionsComponent.prototype.formGroupOptions = function (collection, selectedOptions) {
            /** @type {?} */
            var selectedIds = this.multiple ?
                (selectedOptions || []).map(( /**
                 * @param {?} s
                 * @return {?}
                 */function (/**
                 * @param {?} s
                 * @return {?}
                 */ s) { return s.id; })) :
                selectedOptions ? [selectedOptions.id]
                    : [];
            /** @type {?} */
            var values = collection.map(( /**
             * @param {?} v
             * @return {?}
             */function (/**
             * @param {?} v
             * @return {?}
             */ v) { return (Object.assign(Object.assign({}, v), { ticked: !v.isGroup ? selectedIds.indexOf(v.id) !== -1 : v.ticked })); }));
            this.groupedOptions = this.multiselectService.virtualOptionsGroupingFlatten(values, this.groupedProperty);
            this.updateRange({ start: this.start, end: this.end });
        };
        /**
         * @param {?} option
         * @return {?}
         */
        GroupedOptionsComponent.prototype.getOptionStyle = function (option) {
            return {
                group: option.isGroup,
                marked: option.ticked,
                disabled: this.disabled || option.disabled
            };
        };
        /**
         * @param {?} _
         * @param {?} option
         * @return {?}
         */
        GroupedOptionsComponent.prototype.trackByFn = function (_, option) {
            return option.id;
        };
        /**
         * @param {?} __0
         * @return {?}
         */
        GroupedOptionsComponent.prototype.updateRange = function (_a) {
            var start = _a.start, end = _a.end;
            this.start = start;
            this.end = end;
            this.filteredOptions = __spread(this.options).slice(start, end);
        };
        /**
         * @param {?} option
         * @return {?}
         */
        GroupedOptionsComponent.prototype.select = function (option) {
            if (!option.isGroup) {
                this.selectOption.emit(option);
            }
            else {
                option.ticked = !option.ticked;
                /** @type {?} */
                var values = this.multiselectService.collectAllDescendants(this.options, this.groupedProperty, option.name);
                this.selectGroup.emit(Object.assign(Object.assign({}, option), { values: values }));
            }
        };
        /**
         * @return {?}
         */
        GroupedOptionsComponent.prototype.ngOnInit = function () {
        };
        /**
         * @return {?}
         */
        GroupedOptionsComponent.prototype.ngOnChanges = function () {
            if (!this.optionsTemplate) {
                this.optionsTemplate = this.defaultOptionsTemplate;
            }
        };
        return GroupedOptionsComponent;
    }());
    GroupedOptionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ms-grouped-options',
                    template: "<div class=\"options-container\" msVirtualScroll [totalCount]=\"options.length\" (rangeChanged)=\"updateRange($event)\">\n  <div #top class=\"top\"></div>\n  <ng-container *ngIf=\"filteredOptions.length; else noOptions\">\n    <div\n      class=\"option\"\n      [ngStyle]=\"{ marginLeft: option.depth * 15 + 'px' }\"\n      [ngClass]=\"getOptionStyle(option)\"\n      *ngFor=\"let option of filteredOptions; trackBy: trackByFn\"\n      (click)=\"select(option)\"\n    >\n      <ng-container\n        *ngTemplateOutlet=\"\n          optionsTemplate;\n          context: {\n            option: option\n          }\n        \"\n      ></ng-container>\n    </div>\n  </ng-container>\n  <div #bottom class=\"bottom\"></div>\n</div>\n<ng-template #defaultOptionsTemplate let-option=\"option\">\n  {{ option?.name }}\n</ng-template>\n<ng-template #noOptions let-option=\"option\">\n  <div class=\"option message\">\n    No options available.\n  </div>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    GroupedOptionsComponent.ctorParameters = function () { return [
        { type: NgxMultiselectService }
    ]; };
    GroupedOptionsComponent.propDecorators = {
        groupedProperty: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        multiple: [{ type: i0.Input }],
        selectedOptions: [{ type: i0.Input }],
        optionsTemplate: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        selectGroup: [{ type: i0.Output }],
        selectOption: [{ type: i0.Output }],
        defaultOptionsTemplate: [{ type: i0.ViewChild, args: ['defaultOptionsTemplate', { static: true },] }]
    };
    if (false) {
        /** @type {?} */
        GroupedOptionsComponent.prototype._options;
        /** @type {?} */
        GroupedOptionsComponent.prototype._selectedOptions;
        /** @type {?} */
        GroupedOptionsComponent.prototype.groupedOptions;
        /** @type {?} */
        GroupedOptionsComponent.prototype.start;
        /** @type {?} */
        GroupedOptionsComponent.prototype.end;
        /** @type {?} */
        GroupedOptionsComponent.prototype.filteredOptions;
        /** @type {?} */
        GroupedOptionsComponent.prototype.groupedProperty;
        /** @type {?} */
        GroupedOptionsComponent.prototype.disabled;
        /** @type {?} */
        GroupedOptionsComponent.prototype.multiple;
        /** @type {?} */
        GroupedOptionsComponent.prototype.optionsTemplate;
        /** @type {?} */
        GroupedOptionsComponent.prototype.selectGroup;
        /** @type {?} */
        GroupedOptionsComponent.prototype.selectOption;
        /** @type {?} */
        GroupedOptionsComponent.prototype.defaultOptionsTemplate;
        /** @type {?} */
        GroupedOptionsComponent.prototype.multiselectService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/virtual-scroll.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var VirtualScrollDirective = /** @class */ (function () {
        /**
         * @param {?} el
         * @param {?} renderer
         */
        function VirtualScrollDirective(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.scrollOffset = 0;
            this.itemHeight = 40;
            this.rangeChanged = new i0.EventEmitter();
            this.lastScrollFireTime = 0;
        }
        Object.defineProperty(VirtualScrollDirective.prototype, "totalCount", {
            /**
             * @param {?} count
             * @return {?}
             */
            set: function (count) {
                this._totalCount = count;
                count ? this.initialSetup() : this.reset();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        VirtualScrollDirective.prototype.get = function () {
            return this._totalCount;
        };
        /**
         * @return {?}
         */
        VirtualScrollDirective.prototype.reset = function () {
            if (this.top && this.bottom) {
                this.renderer.setStyle(this.top, 'height', 0);
                this.renderer.setStyle(this.bottom, 'height', 0);
                this.renderer.setProperty(this.el.nativeElement, 'scrollTop', 0);
            }
        };
        /**
         * @param {?} target
         * @return {?}
         */
        VirtualScrollDirective.prototype.throttleScroll = function (target) {
            var scrollTop = target.scrollTop, clientHeight = target.clientHeight;
            /** @type {?} */
            var totalHeight = this.itemHeight * this._totalCount + this.scrollOffset;
            // Step: 1 - Calculate the position
            /** @type {?} */
            var topSpacing = scrollTop;
            /** @type {?} */
            var maxItemsRange = (clientHeight - this.scrollOffset) / this.itemHeight;
            // Step: 2 - What are the possible collection that can be rendered
            /** @type {?} */
            var rangeOffset = topSpacing % this.itemHeight;
            /** @type {?} */
            var rangeStart = topSpacing - rangeOffset;
            /** @type {?} */
            var topNonVisible = topSpacing / this.itemHeight;
            /** @type {?} */
            var itemStartRange = Math.floor(topNonVisible);
            /** @type {?} */
            var rangeToBeIncreamented = rangeOffset ? maxItemsRange + 1 : maxItemsRange;
            /** @type {?} */
            var calculatedEndRange = itemStartRange + rangeToBeIncreamented;
            /** @type {?} */
            var itemEndRange = calculatedEndRange >= this._totalCount ? this._totalCount : calculatedEndRange;
            /** @type {?} */
            var bottomSpacing = totalHeight - (rangeStart + rangeToBeIncreamented * this.itemHeight);
            // Step: 3 - Pass the range to the child directive
            this.renderer.setStyle(this.top, 'height', rangeStart + "px");
            this.renderer.setStyle(this.bottom, 'height', bottomSpacing + "px");
            this.rangeChanged.emit({ start: itemStartRange, end: itemEndRange });
        };
        /**
         * @param {?} __0
         * @return {?}
         */
        VirtualScrollDirective.prototype.onscroll = function (_a) {
            var _this = this;
            var target = _a.target;
            /** @type {?} */
            var minScrollTime = 50;
            /** @type {?} */
            var now = new Date().getTime();
            if (!this.scrollTimer) {
                if (now - this.lastScrollFireTime > minScrollTime) {
                    this.lastScrollFireTime = now;
                }
                this.scrollTimer = setTimeout(( /**
                 * @return {?}
                 */function () {
                    _this.scrollTimer = null;
                    _this.lastScrollFireTime = new Date().getTime();
                    _this.throttleScroll(target);
                }), minScrollTime);
            }
        };
        /**
         * @return {?}
         */
        VirtualScrollDirective.prototype.initialSetup = function () {
            // TODO: later think of usng ViewChild, instead of direct DOM manipulation.
            var _a = this.el.nativeElement, scrollTop = _a.scrollTop, clientHeight = _a.clientHeight;
            this.top = this.renderer.selectRootElement('.top');
            this.bottom = this.renderer.selectRootElement('.bottom');
            this.renderer.setStyle(this.top, 'height', scrollTop + "px");
            this.renderer.setStyle(this.bottom, 'height', this.itemHeight * this._totalCount + this.scrollOffset - clientHeight + "px");
            this.renderer.setProperty(this.el.nativeElement, 'scrollTop', 0);
        };
        return VirtualScrollDirective;
    }());
    VirtualScrollDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[msVirtualScroll]'
                },] }
    ];
    /** @nocollapse */
    VirtualScrollDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    VirtualScrollDirective.propDecorators = {
        itemHeight: [{ type: i0.Input }],
        totalCount: [{ type: i0.Input }],
        rangeChanged: [{ type: i0.Output }],
        onscroll: [{ type: i0.HostListener, args: ['scroll', ['$event'],] }]
    };
    if (false) {
        /**
         * @type {?}
         * @private
         */
        VirtualScrollDirective.prototype._totalCount;
        /** @type {?} */
        VirtualScrollDirective.prototype.top;
        /** @type {?} */
        VirtualScrollDirective.prototype.bottom;
        /** @type {?} */
        VirtualScrollDirective.prototype.scrollOffset;
        /** @type {?} */
        VirtualScrollDirective.prototype.itemHeight;
        /** @type {?} */
        VirtualScrollDirective.prototype.rangeChanged;
        /**
         * @type {?}
         * @private
         */
        VirtualScrollDirective.prototype.scrollTimer;
        /**
         * @type {?}
         * @private
         */
        VirtualScrollDirective.prototype.lastScrollFireTime;
        /**
         * @type {?}
         * @private
         */
        VirtualScrollDirective.prototype.el;
        /**
         * @type {?}
         * @private
         */
        VirtualScrollDirective.prototype.renderer;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/multiselect.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMultiselectModule = /** @class */ (function () {
        function NgxMultiselectModule() {
        }
        return NgxMultiselectModule;
    }());
    NgxMultiselectModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule, forms.FormsModule, forms.ReactiveFormsModule],
                    declarations: [
                        NgxMultiselectComponent,
                        DisplaySelectedValuePipe,
                        HelperElementsComponent,
                        FilterOptionsComponent,
                        OptionsComponent,
                        GroupedOptionsComponent,
                        VirtualScrollDirective
                    ],
                    exports: [NgxMultiselectComponent, DisplaySelectedValuePipe]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: ngx-lib-multiselect.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.DEFAULT_VALUE_ACCESSOR = DEFAULT_VALUE_ACCESSOR;
    exports.DisplaySelectedValuePipe = DisplaySelectedValuePipe;
    exports.FilterOptionsComponent = FilterOptionsComponent;
    exports.GroupedOptionsComponent = GroupedOptionsComponent;
    exports.HelperElementsComponent = HelperElementsComponent;
    exports.NgxMultiselectComponent = NgxMultiselectComponent;
    exports.NgxMultiselectModule = NgxMultiselectModule;
    exports.NgxMultiselectService = NgxMultiselectService;
    exports.OptionsComponent = OptionsComponent;
    exports.ɵa = VirtualScrollDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-lib-multiselect.umd.js.map
