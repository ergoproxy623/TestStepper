import { ElementRef, TemplateRef, EventEmitter } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { NgxMultiselectService } from './services/multiselect.service';
import * as ɵngcc0 from '@angular/core';
export declare const DEFAULT_VALUE_ACCESSOR: any;
export declare class NgxMultiselectComponent implements ControlValueAccessor {
    private elementRef;
    private multiselectService;
    constructor(elementRef: ElementRef, multiselectService: NgxMultiselectService);
    private _multiple;
    private _theme;
    private _optionsCopy;
    private _isOpen;
    private operationPendingQueue;
    _selectedOptions: any | any[];
    _defaultPropertyMap: {
        id: string;
        name: string;
        disabled: string;
    };
    _defaultPropertyMapLength: number;
    _options: any;
    matMultiselect: boolean;
    bsMultiselect: boolean;
    disabled: boolean;
    color: string;
    groupedProperty: string;
    showHelperElements: boolean;
    showSearchFilter: boolean;
    showMaxLabels: number;
    _optionsTemplate: TemplateRef<any>;
    get optionsTemplate(): TemplateRef<any>;
    set optionsTemplate(template: TemplateRef<any>);
    get theme(): string;
    set theme(val: string);
    set isOpen(value: boolean);
    get isOpen(): boolean;
    set propertyMap(val: any);
    get multiple(): boolean;
    set multiple(value: boolean);
    set options(collection: any);
    onOpen: EventEmitter<any>;
    onClose: EventEmitter<any>;
    onItemClick: EventEmitter<any>;
    onGroupItemClick: EventEmitter<any>;
    onSelectAll: EventEmitter<any>;
    onSelectNone: EventEmitter<any>;
    onReset: EventEmitter<any>;
    onClear: EventEmitter<any>;
    onSearchChange: EventEmitter<any>;
    filterOptions: any;
    addOperation(item: any): void;
    popOperation(): any;
    finishPendingOperations(): void;
    isOperationPending(): number;
    private _initialValue;
    set initialValue(value: any);
    get initialValue(): any;
    onChange: (_: any) => void;
    onTouched: () => void;
    writeValue(value: any): void;
    private formatPrepopulatedValues;
    registerOnChange(fn: (value: any) => any): void;
    registerOnTouched(fn: () => any): void;
    setOptions(options: any): void;
    getOptions(): any[];
    getOptionsCopy(): any[];
    filterOptionsList: (val: string) => void;
    isValueSelected(): any;
    searchChange(val: string): void;
    close(): void;
    removeItem(collection: any, item: any): void;
    toggleDropdown(): void;
    prepopulateOptions(selected: any): void;
    select(option: any): void;
    selectAll(): void;
    selectNone(): void;
    borderBottom(): {
        borderBottom: string;
    } | {
        borderBottom?: undefined;
    };
    selectGroup(group: any): void;
    reset(): void;
    viewToModel(selected: any): void;
    clear(event: any): void;
    setDisabledState(isDisabled: boolean): void;
    ngOnInit(): void;
    clickOutSide(event: any): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgxMultiselectComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NgxMultiselectComponent, "ngx-multiselect", never, { "disabled": "disabled"; "color": "color"; "showHelperElements": "showHelperElements"; "showSearchFilter": "showSearchFilter"; "showMaxLabels": "showMaxLabels"; "optionsTemplate": "optionsTemplate"; "theme": "theme"; "isOpen": "isOpen"; "propertyMap": "propertyMap"; "multiple": "multiple"; "options": "options"; "groupedProperty": "groupedProperty"; }, { "onOpen": "onOpen"; "onClose": "onClose"; "onItemClick": "onItemClick"; "onGroupItemClick": "onGroupItemClick"; "onSelectAll": "onSelectAll"; "onSelectNone": "onSelectNone"; "onReset": "onReset"; "onClear": "onClear"; "onSearchChange": "onSearchChange"; }, ["_optionsTemplate"], never>;
}

//# sourceMappingURL=multiselect.component.d.ts.map